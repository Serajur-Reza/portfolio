[
  {
    "title": "SOLID Principle is Easy in React",
    "pubDate": "2025-10-15 12:53:34",
    "link": "https://javascript.plainenglish.io/solid-principle-is-easy-in-react-25f60a8f1fbd?source=rss-eea2b02f8c4c------2",
    "guid": "https://medium.com/p/25f60a8f1fbd",
    "author": "Serajur Reza Chowdhury",
    "thumbnail": "",
    "description": "\n<p>SOLID is an architecture for software development. It makes code clean, easy to read and manage. Whatever technology you develop your application, design patterns are important because it gives an improved structure for your application.</p>\n<p>Here, we will describe about SOLID principles inÂ React</p>\n<p>The expansion ofÂ SOLID,</p>\n<p>Sâ€Šâ€”â€ŠSingle Responsibility Principle</p>\n<p>Oâ€Šâ€”â€ŠOpen/Closed Principle</p>\n<p>Lâ€Šâ€”â€ŠLiskov Substitution Principle</p>\n<p>Iâ€Šâ€”â€ŠInterface Segregation Principle</p>\n<p>Dâ€Šâ€”â€ŠDependency Inversion Principle</p>\n<p>Now, we will describe about the these 5 principles inÂ React.</p>\n<h3>Single Responsibility Principle</h3>\n<p><strong>Principle</strong>: A class or component should have one, and only one, reason to change. It should be responsible for only one piece of functionality.</p>\n<p><strong>In React:</strong> In the single responsibility principle, one component will have only one responsibility. Which one component will perform only one action. Here, each component will have a single responsibililty to avoid complexity of a component. Each component will have its own event handler, effects, UI etc. Those things will only managed inside the specific component. Nothing more, nothingÂ less.</p>\n<p>We can apply this principle by creating a single component for a singleÂ purpose.</p>\n<p>Letâ€™s consider the login and register form of an application.</p>\n<p>login.tsx</p>\n<a href=\"https://medium.com/media/db7cb218434cfa5c985edf5b9d97fb43/href\">https://medium.com/media/db7cb218434cfa5c985edf5b9d97fb43/href</a><p>register.tsx</p>\n<a href=\"https://medium.com/media/ac4de79818c164520a8113ee1898dd89/href\">https://medium.com/media/ac4de79818c164520a8113ee1898dd89/href</a><p>Here, for login purpose the login component is used and for register purpose the register component isÂ used.</p>\n<h3>Open/Closed Principle</h3>\n<p><strong>Principle</strong>: Software entities (classes, modules, functions) should be open for extension but closed for modification.</p>\n<p><strong>In React:</strong> Here, a component will be available for exentension but not for modification. Which means you cannot modify the code inside it but you can extend its properties.</p>\n<p>We can do this by passing props inside a component by making the component a reusableÂ one.</p>\n<p>Letâ€™s see the example of a button component,</p>\n<pre>const Button = (props) =&gt; {<br>  const {clickHandler, background} = props<br>  return (<br><br>  &lt;button<br>    type=\"button\"<br>    className=\"rounded-md px-[20px] py-[10px] text-white\"<br>    onClick={clickHandler}<br>    style={{backgroundColor: background}}<br>  &gt;<br>    Click<br>  &lt;/button&gt;<br>  );<br>};</pre>\n<p>In this button component, it takes clickhandler, which is an event handler and background, which is the background color of the button as props. Anywhere in our application we can use this button component by passing these two props. But we cannot change the code inside the button component while we useÂ it.</p>\n<h3>Liskovâ€™s Substitution Principle</h3>\n<p><strong>Principle</strong>: Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of theÂ program.</p>\n<p><strong>In React: </strong>A component which is derived from another component can substitute all the properties of base component.</p>\n<p>For example, we can have a Button component and a SubmitButton component. The SubmitButton will have a behavior that will replace the specific behavior of the Button component.</p>\n<pre>// Base button<br>const Button = ({ children, onClick }) =&gt; {<br>  return &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;;<br>};<br><br>// Submit button, extending the base button<br>const SubmitButton = (props) =&gt; {<br>  return &lt;Button {...props} onClick={() =&gt; console.log(\"Form submitted!\")}&gt;Submit&lt;/Button&gt;;<br>};<br><br>// In the component<br>&lt;Button onClick={() =&gt; console.log(\"Button clicked!\")}&gt;Click Me&lt;/Button&gt;<br>&lt;SubmitButton /&gt;</pre>\n<p>Here, the SubmitButton componentâ€™s onClick is replacing the Button componentâ€™s onClick.</p>\n<p>The thing is, when you a create a child component from the base component, the child will substitute something of its parent with itsÂ own.</p>\n<h3>Interface Segregation Principle</h3>\n<p><strong>Principle</strong>: Clients should not be forced to depend on interfaces they do notÂ use.</p>\n<p><strong>In React:</strong> This theory focuses on simple, short components with neccessary only props and logic. Components should be broken into as small pieces as possible and only required logics, props, interfaces should be there to keep precise, short, readable as well as manageable.</p>\n<pre>// component excessive and useless props<br>const Profile = ({ name, age, contact}) =&gt; {<br>  return &lt;div&gt;<br>    &lt;div&gt;{children}&lt;/div&gt;<br>    &lt;div&gt;{name}&lt;/div&gt;<br>  &lt;/div&gt;;<br>};<br><br><br>// component with required props<br>const Profile = ({ name, age}) =&gt; {<br>  return &lt;div&gt;<br>    &lt;div&gt;{children}&lt;/div&gt;<br>    &lt;div&gt;{name}&lt;/div&gt;<br>  &lt;/div&gt;;<br>};<br><br>// component with required props<br>const Actions = ({logout, login}) =&gt; {<br>  return &lt;div&gt;<br>    &lt;Button onClick={() =&gt; logout()}&gt;Log Out&lt;/Button&gt;<br>    &lt;Button onClick={() =&gt; login()}&gt;Log In&lt;/Button&gt;<br>  &lt;/div&gt; ;<br>};</pre>\n<p>Here, the first profile component has an extra prop contact which is not inside the component. It was fixed inside the second component. And for the third component have the required props but it has a different purpose, handling different events. So, one is for showing data and other is for interactions.</p>\n<h3>Dependency Inversion Principle</h3>\n<p><strong>Principle</strong>: High-level modules should not depend on low-level modules. Both should depend on abstractions.</p>\n<p><strong>In React:</strong> This theory encourages to use dependency injection and use effects externally. Here, the external events are passed by props or context inside the application.</p>\n<blockquote>Dependency injection is a programming technique where an object or function receives its dependencies from an external source rather than creating them internally.</blockquote>\n<p>Letâ€™s look at the following example,</p>\n<pre>// Data fetching component<br>const DataComponent = ({ fetchData }) =&gt; {<br>  const [data, setData] = React.useState(null);<br><br>  React.useEffect(() =&gt; {<br>    fetchData().then(setData);<br>  }, [fetchData]);<br><br>  return &lt;div&gt;{data ? JSON.stringify(data) : \"Loading...\"}&lt;/div&gt;;<br>};</pre>\n<p>component with external data-fetching(following the principle)</p>\n<pre>// Example service function for fetching data<br>const fetchMovies = () =&gt; {<br>  return fetch(\"/api/movies\")<br>    .then((response) =&gt; response.json())<br>    .catch((error) =&gt; console.error(\"Error fetching movies:\", error));<br>};<br><br>// Inject the service into the component<br>const App = () =&gt; {<br>  return &lt;DataComponent fetchData={fetchMovies} /&gt;;<br>};<br><br>export default App;</pre>\n<p>This fetchdata function passed as props to the DataComponent component, to avoid the component being dependent on the external source. The component gets the data from the function. So, the function itself works as a dependency injection.</p>\n<h3>Conclusion</h3>\n<p>SOLID principle improves code quality, increases readability, helps you to write scalable application. While building small components for a large scale application, it helps to follow a better component architecture.</p>\n<h3>A message from ourÂ Founder</h3>\n<p><strong>Hey, </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>Sunil</strong></a><strong> here.</strong> I wanted to take a moment to thank you for reading until the end and for being a part of this community.</p>\n<p>Did you know that our team run these publications as a volunteer effort to over 3.5m monthly readers? <strong>We donâ€™t receive any funding, we do this to support the community. â¤ï¸</strong></p>\n<p>If you want to show some love, please take a moment to <strong>follow me on </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>LinkedIn</strong></a><strong>, </strong><a href=\"https://tiktok.com/@messyfounder\"><strong>TikTok</strong></a>, <a href=\"https://instagram.com/sunilsandhu\"><strong>Instagram</strong></a>. You can also subscribe to our <a href=\"https://newsletter.plainenglish.io/\"><strong>weekly newsletter</strong></a>.</p>\n<p>And before you go, donâ€™t forget to <strong>clap</strong> and <strong>follow</strong> theÂ writerï¸!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=25f60a8f1fbd\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://javascript.plainenglish.io/solid-principle-is-easy-in-react-25f60a8f1fbd\">SOLID Principle is Easy in React</a> was originally published in <a href=\"https://javascript.plainenglish.io/\">JavaScript in Plain English</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "content": "\n<p>SOLID is an architecture for software development. It makes code clean, easy to read and manage. Whatever technology you develop your application, design patterns are important because it gives an improved structure for your application.</p>\n<p>Here, we will describe about SOLID principles inÂ React</p>\n<p>The expansion ofÂ SOLID,</p>\n<p>Sâ€Šâ€”â€ŠSingle Responsibility Principle</p>\n<p>Oâ€Šâ€”â€ŠOpen/Closed Principle</p>\n<p>Lâ€Šâ€”â€ŠLiskov Substitution Principle</p>\n<p>Iâ€Šâ€”â€ŠInterface Segregation Principle</p>\n<p>Dâ€Šâ€”â€ŠDependency Inversion Principle</p>\n<p>Now, we will describe about the these 5 principles inÂ React.</p>\n<h3>Single Responsibility Principle</h3>\n<p><strong>Principle</strong>: A class or component should have one, and only one, reason to change. It should be responsible for only one piece of functionality.</p>\n<p><strong>In React:</strong> In the single responsibility principle, one component will have only one responsibility. Which one component will perform only one action. Here, each component will have a single responsibililty to avoid complexity of a component. Each component will have its own event handler, effects, UI etc. Those things will only managed inside the specific component. Nothing more, nothingÂ less.</p>\n<p>We can apply this principle by creating a single component for a singleÂ purpose.</p>\n<p>Letâ€™s consider the login and register form of an application.</p>\n<p>login.tsx</p>\n<a href=\"https://medium.com/media/db7cb218434cfa5c985edf5b9d97fb43/href\">https://medium.com/media/db7cb218434cfa5c985edf5b9d97fb43/href</a><p>register.tsx</p>\n<a href=\"https://medium.com/media/ac4de79818c164520a8113ee1898dd89/href\">https://medium.com/media/ac4de79818c164520a8113ee1898dd89/href</a><p>Here, for login purpose the login component is used and for register purpose the register component isÂ used.</p>\n<h3>Open/Closed Principle</h3>\n<p><strong>Principle</strong>: Software entities (classes, modules, functions) should be open for extension but closed for modification.</p>\n<p><strong>In React:</strong> Here, a component will be available for exentension but not for modification. Which means you cannot modify the code inside it but you can extend its properties.</p>\n<p>We can do this by passing props inside a component by making the component a reusableÂ one.</p>\n<p>Letâ€™s see the example of a button component,</p>\n<pre>const Button = (props) =&gt; {<br>  const {clickHandler, background} = props<br>  return (<br><br>  &lt;button<br>    type=\"button\"<br>    className=\"rounded-md px-[20px] py-[10px] text-white\"<br>    onClick={clickHandler}<br>    style={{backgroundColor: background}}<br>  &gt;<br>    Click<br>  &lt;/button&gt;<br>  );<br>};</pre>\n<p>In this button component, it takes clickhandler, which is an event handler and background, which is the background color of the button as props. Anywhere in our application we can use this button component by passing these two props. But we cannot change the code inside the button component while we useÂ it.</p>\n<h3>Liskovâ€™s Substitution Principle</h3>\n<p><strong>Principle</strong>: Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of theÂ program.</p>\n<p><strong>In React: </strong>A component which is derived from another component can substitute all the properties of base component.</p>\n<p>For example, we can have a Button component and a SubmitButton component. The SubmitButton will have a behavior that will replace the specific behavior of the Button component.</p>\n<pre>// Base button<br>const Button = ({ children, onClick }) =&gt; {<br>  return &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;;<br>};<br><br>// Submit button, extending the base button<br>const SubmitButton = (props) =&gt; {<br>  return &lt;Button {...props} onClick={() =&gt; console.log(\"Form submitted!\")}&gt;Submit&lt;/Button&gt;;<br>};<br><br>// In the component<br>&lt;Button onClick={() =&gt; console.log(\"Button clicked!\")}&gt;Click Me&lt;/Button&gt;<br>&lt;SubmitButton /&gt;</pre>\n<p>Here, the SubmitButton componentâ€™s onClick is replacing the Button componentâ€™s onClick.</p>\n<p>The thing is, when you a create a child component from the base component, the child will substitute something of its parent with itsÂ own.</p>\n<h3>Interface Segregation Principle</h3>\n<p><strong>Principle</strong>: Clients should not be forced to depend on interfaces they do notÂ use.</p>\n<p><strong>In React:</strong> This theory focuses on simple, short components with neccessary only props and logic. Components should be broken into as small pieces as possible and only required logics, props, interfaces should be there to keep precise, short, readable as well as manageable.</p>\n<pre>// component excessive and useless props<br>const Profile = ({ name, age, contact}) =&gt; {<br>  return &lt;div&gt;<br>    &lt;div&gt;{children}&lt;/div&gt;<br>    &lt;div&gt;{name}&lt;/div&gt;<br>  &lt;/div&gt;;<br>};<br><br><br>// component with required props<br>const Profile = ({ name, age}) =&gt; {<br>  return &lt;div&gt;<br>    &lt;div&gt;{children}&lt;/div&gt;<br>    &lt;div&gt;{name}&lt;/div&gt;<br>  &lt;/div&gt;;<br>};<br><br>// component with required props<br>const Actions = ({logout, login}) =&gt; {<br>  return &lt;div&gt;<br>    &lt;Button onClick={() =&gt; logout()}&gt;Log Out&lt;/Button&gt;<br>    &lt;Button onClick={() =&gt; login()}&gt;Log In&lt;/Button&gt;<br>  &lt;/div&gt; ;<br>};</pre>\n<p>Here, the first profile component has an extra prop contact which is not inside the component. It was fixed inside the second component. And for the third component have the required props but it has a different purpose, handling different events. So, one is for showing data and other is for interactions.</p>\n<h3>Dependency Inversion Principle</h3>\n<p><strong>Principle</strong>: High-level modules should not depend on low-level modules. Both should depend on abstractions.</p>\n<p><strong>In React:</strong> This theory encourages to use dependency injection and use effects externally. Here, the external events are passed by props or context inside the application.</p>\n<blockquote>Dependency injection is a programming technique where an object or function receives its dependencies from an external source rather than creating them internally.</blockquote>\n<p>Letâ€™s look at the following example,</p>\n<pre>// Data fetching component<br>const DataComponent = ({ fetchData }) =&gt; {<br>  const [data, setData] = React.useState(null);<br><br>  React.useEffect(() =&gt; {<br>    fetchData().then(setData);<br>  }, [fetchData]);<br><br>  return &lt;div&gt;{data ? JSON.stringify(data) : \"Loading...\"}&lt;/div&gt;;<br>};</pre>\n<p>component with external data-fetching(following the principle)</p>\n<pre>// Example service function for fetching data<br>const fetchMovies = () =&gt; {<br>  return fetch(\"/api/movies\")<br>    .then((response) =&gt; response.json())<br>    .catch((error) =&gt; console.error(\"Error fetching movies:\", error));<br>};<br><br>// Inject the service into the component<br>const App = () =&gt; {<br>  return &lt;DataComponent fetchData={fetchMovies} /&gt;;<br>};<br><br>export default App;</pre>\n<p>This fetchdata function passed as props to the DataComponent component, to avoid the component being dependent on the external source. The component gets the data from the function. So, the function itself works as a dependency injection.</p>\n<h3>Conclusion</h3>\n<p>SOLID principle improves code quality, increases readability, helps you to write scalable application. While building small components for a large scale application, it helps to follow a better component architecture.</p>\n<h3>A message from ourÂ Founder</h3>\n<p><strong>Hey, </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>Sunil</strong></a><strong> here.</strong> I wanted to take a moment to thank you for reading until the end and for being a part of this community.</p>\n<p>Did you know that our team run these publications as a volunteer effort to over 3.5m monthly readers? <strong>We donâ€™t receive any funding, we do this to support the community. â¤ï¸</strong></p>\n<p>If you want to show some love, please take a moment to <strong>follow me on </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>LinkedIn</strong></a><strong>, </strong><a href=\"https://tiktok.com/@messyfounder\"><strong>TikTok</strong></a>, <a href=\"https://instagram.com/sunilsandhu\"><strong>Instagram</strong></a>. You can also subscribe to our <a href=\"https://newsletter.plainenglish.io/\"><strong>weekly newsletter</strong></a>.</p>\n<p>And before you go, donâ€™t forget to <strong>clap</strong> and <strong>follow</strong> theÂ writerï¸!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=25f60a8f1fbd\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://javascript.plainenglish.io/solid-principle-is-easy-in-react-25f60a8f1fbd\">SOLID Principle is Easy in React</a> was originally published in <a href=\"https://javascript.plainenglish.io/\">JavaScript in Plain English</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "enclosure": {},
    "categories": ["reactjs", "solid-principles"]
  },
  {
    "title": "Deep Dive into Effects in React",
    "pubDate": "2025-09-28 07:36:14",
    "link": "https://javascript.plainenglish.io/deep-dive-into-effects-in-react-c2b421cbf58e?source=rss-eea2b02f8c4c------2",
    "guid": "https://medium.com/p/c2b421cbf58e",
    "author": "Serajur Reza Chowdhury",
    "thumbnail": "",
    "description": "\n<p>Effects are some code that runs outside the React ecosystem after rendering. Such as, database/server connection, some timer function etc. In react, some components needs effects so that it can be synchronized with externalÂ systems.</p>\n<p>The best practice is use effects while connecting to external events only, and that is the sole purpose ofÂ effects.</p>\n<p>Effects follow a lifecycle and its completely different from the component. It can only do 2 things. Start synchronizing something and stop synchronizing later. This lifecycle depends on change of props and states. These are called dependencies, where the lifecycle of effect dependsÂ on.</p>\n<h3>The Lifecycle ofÂ Effects</h3>\n<p>Every React component goes through the same lifecycle:</p>\n<ul>\n<li>A component <em>mounts</em> when itâ€™s added to theÂ screen.</li>\n<li>A component <em>updates</em> when it receives new props or state, usually in response to an interaction.</li>\n<li>A component <em>unmounts</em> when itâ€™s removed from theÂ screen.</li>\n</ul>\n<p>Now, this is the lifecycle of the components, not the effects. Effects run differently from the components. Effects make sure the props and states are synchronized with external systems inside a component.</p>\n<p>Letâ€™s have a look at the following snippet,</p>\n<pre>import React, { useState, useEffect } from 'react';<br><br>function WindowTracker() {<br>  const [windowWidth, setWindowWidth] = useState(window.innerWidth);<br><br>  useEffect(() =&gt; {<br>    function handleResize() {<br>      console.log('Window was resized!');<br>      setWindowWidth(window.innerWidth);<br>    }<br><br>    window.addEventListener('resize', handleResize);    <br>    console.log('Event listener added.');<br><br>    // cleanup<br>    return () =&gt; {<br>      window.removeEventListener('resize', handleResize);<br>      console.log('Event listener removed. Cleanup complete!');<br>    };<br><br>  }, []); // The empty array [] means this effect runs only once on mount.<br><br>  return (<br>    &lt;div&gt;<br>      &lt;h2&gt;Resize the browser window ğŸ“&lt;/h2&gt;<br>      &lt;p&gt;Current window width: {windowWidth}px&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>export default WindowTracker;</pre>\n<p>Here, react will synchronize the component with the effect when the component mounts and will stop synchronizing when the component unmounts. Why? Because there is nothing in the dependency array.</p>\n<p>What will happen if there is something in the dependency array?</p>\n<p>Letâ€™s see the code again with smallÂ changes,</p>\n<pre>import React, { useState, useEffect } from 'react';<br><br>function WindowTracker({userId}) {<br>  const [windowWidth, setWindowWidth] = useState(window.innerWidth);<br><br>  useEffect(() =&gt; {<br>    function handleResize() {<br>      console.log('Window was resized!');<br>      setWindowWidth(window.innerWidth);<br>    }<br><br>    window.addEventListener('resize', handleResize);    <br>    console.log('Event listener added.');<br><br>    // cleanup<br>    return () =&gt; {<br>      window.removeEventListener('resize', handleResize);<br>      console.log('Event listener removed. Cleanup complete!');<br>    };<br><br>  }, [userId]); // If the userId changes the effect will run again.<br><br>  return (<br>    &lt;div&gt;<br>      &lt;h2&gt;Resize the browser window ğŸ“&lt;/h2&gt;<br>      &lt;p&gt;Current window width: {windowWidth}px&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>export default WindowTracker;</pre>\n<p>Here we have taken a userId as a prop in the component. And we also put that into a dependency array. Dependency means the things that gets modified triggers a re run onÂ effect.</p>\n<p>For a specific userId the effect will synchronize with the component. But if we modify the userId and call the component, It will disconnect the effect from the old userId and synchronize the effect with a newÂ userId.</p>\n<p>The body of the effect specifies how to start synchronizing and the cleanup function specifies how to stop synchronizing.</p>\n<p>For example, you called the component with userId 1. It will start synchronizing the component with effect with the value of 1. The moment you change it to 2, the cleanup function will run and the effect and the component will be synchronized with valueÂ 2.</p>\n<p>So, the effect will run if and onlyÂ if</p>\n<blockquote><strong>the userId changes, not the windowWidth. Because userId is in the dependency array, windowWidth isÂ not.</strong></blockquote>\n<p>If there would have been multple elements in the dependency array, modification of atleast a single element will be enough to re run theÂ effect.</p>\n<h3>How React Handles Dependency Array</h3>\n<p>If you configure your linter for React, it will tell you about the dependencies required to be put inside the dependency array.</p>\n<pre>import React, { useState, useEffect } from 'react';<br><br>function WindowTracker({userId}) {<br>  const [windowWidth, setWindowWidth] = useState(window.innerWidth);<br>  const value = 123<br><br>  useEffect(() =&gt; {<br>    function handleResize() {<br>      console.log('Window was resized!');<br>      setWindowWidth(window.innerWidth);<br>    }<br><br>    window.addEventListener('resize', handleResize);    <br>    console.log('Event listener added.');<br><br>    // cleanup<br>    return () =&gt; {<br>      window.removeEventListener('resize', handleResize);<br>      console.log('Event listener removed. Cleanup complete!');<br>    };<br><br>  }, []); // The editor will suggest you to put userId in the dependencey array<br><br>  return (<br>    &lt;div&gt;<br>      &lt;h2&gt;Resize the browser window ğŸ“&lt;/h2&gt;<br>      &lt;p&gt;Current window width: {windowWidth}px&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>export default WindowTracker;</pre>\n<p>The code will run smoothly. However, the editor will suggest you put userId in the dependency array. As, modifying it will re run theÂ effect.</p>\n<p>We can put the value variable in the dependency array. Still the code will run smoothly. But the editor will warn you not to add it. Why? because the value of value does not change in a re-render. You can put it in the dependency array, but as it will not change. The effect will run during the firstÂ mount.</p>\n<h3>Summary</h3>\n<ol>\n<li>Components mount, update andÂ unmount</li>\n<li>Effects have seperate lifecycles than the components</li>\n<li>Each effect can have seperate synchronization process that can start andÂ stop</li>\n<li>Each effect will have its own perspective of synchronization, that does not depend on any other effects in same component or the component itself</li>\n<li>Values declared inside the component body are â€œreactiveâ€</li>\n<li>Reactive values should re-synchronize the Effect because they can change overÂ time.</li>\n<li>The linter verifies that all reactive values used inside the Effect are specified as dependencies.</li>\n<li>All errors flagged by the linter are legitimate. Thereâ€™s always a way to fix the code to not break theÂ rules.</li>\n</ol>\n<h3>A message from ourÂ Founder</h3>\n<p><strong>Hey, </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>Sunil</strong></a><strong> here.</strong> I wanted to take a moment to thank you for reading until the end and for being a part of this community.</p>\n<p>Did you know that our team run these publications as a volunteer effort to over 3.5m monthly readers? <strong>We donâ€™t receive any funding, we do this to support the community. â¤ï¸</strong></p>\n<p>If you want to show some love, please take a moment to <strong>follow me on </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>LinkedIn</strong></a><strong>, </strong><a href=\"https://tiktok.com/@messyfounder\"><strong>TikTok</strong></a>, <a href=\"https://instagram.com/sunilsandhu\"><strong>Instagram</strong></a>. You can also subscribe to our <a href=\"https://newsletter.plainenglish.io/\"><strong>weekly newsletter</strong></a>.</p>\n<p>And before you go, donâ€™t forget to <strong>clap</strong> and <strong>follow</strong> theÂ writerï¸!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c2b421cbf58e\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://javascript.plainenglish.io/deep-dive-into-effects-in-react-c2b421cbf58e\">Deep Dive into Effects in React</a> was originally published in <a href=\"https://javascript.plainenglish.io/\">JavaScript in Plain English</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "content": "\n<p>Effects are some code that runs outside the React ecosystem after rendering. Such as, database/server connection, some timer function etc. In react, some components needs effects so that it can be synchronized with externalÂ systems.</p>\n<p>The best practice is use effects while connecting to external events only, and that is the sole purpose ofÂ effects.</p>\n<p>Effects follow a lifecycle and its completely different from the component. It can only do 2 things. Start synchronizing something and stop synchronizing later. This lifecycle depends on change of props and states. These are called dependencies, where the lifecycle of effect dependsÂ on.</p>\n<h3>The Lifecycle ofÂ Effects</h3>\n<p>Every React component goes through the same lifecycle:</p>\n<ul>\n<li>A component <em>mounts</em> when itâ€™s added to theÂ screen.</li>\n<li>A component <em>updates</em> when it receives new props or state, usually in response to an interaction.</li>\n<li>A component <em>unmounts</em> when itâ€™s removed from theÂ screen.</li>\n</ul>\n<p>Now, this is the lifecycle of the components, not the effects. Effects run differently from the components. Effects make sure the props and states are synchronized with external systems inside a component.</p>\n<p>Letâ€™s have a look at the following snippet,</p>\n<pre>import React, { useState, useEffect } from 'react';<br><br>function WindowTracker() {<br>  const [windowWidth, setWindowWidth] = useState(window.innerWidth);<br><br>  useEffect(() =&gt; {<br>    function handleResize() {<br>      console.log('Window was resized!');<br>      setWindowWidth(window.innerWidth);<br>    }<br><br>    window.addEventListener('resize', handleResize);    <br>    console.log('Event listener added.');<br><br>    // cleanup<br>    return () =&gt; {<br>      window.removeEventListener('resize', handleResize);<br>      console.log('Event listener removed. Cleanup complete!');<br>    };<br><br>  }, []); // The empty array [] means this effect runs only once on mount.<br><br>  return (<br>    &lt;div&gt;<br>      &lt;h2&gt;Resize the browser window ğŸ“&lt;/h2&gt;<br>      &lt;p&gt;Current window width: {windowWidth}px&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>export default WindowTracker;</pre>\n<p>Here, react will synchronize the component with the effect when the component mounts and will stop synchronizing when the component unmounts. Why? Because there is nothing in the dependency array.</p>\n<p>What will happen if there is something in the dependency array?</p>\n<p>Letâ€™s see the code again with smallÂ changes,</p>\n<pre>import React, { useState, useEffect } from 'react';<br><br>function WindowTracker({userId}) {<br>  const [windowWidth, setWindowWidth] = useState(window.innerWidth);<br><br>  useEffect(() =&gt; {<br>    function handleResize() {<br>      console.log('Window was resized!');<br>      setWindowWidth(window.innerWidth);<br>    }<br><br>    window.addEventListener('resize', handleResize);    <br>    console.log('Event listener added.');<br><br>    // cleanup<br>    return () =&gt; {<br>      window.removeEventListener('resize', handleResize);<br>      console.log('Event listener removed. Cleanup complete!');<br>    };<br><br>  }, [userId]); // If the userId changes the effect will run again.<br><br>  return (<br>    &lt;div&gt;<br>      &lt;h2&gt;Resize the browser window ğŸ“&lt;/h2&gt;<br>      &lt;p&gt;Current window width: {windowWidth}px&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>export default WindowTracker;</pre>\n<p>Here we have taken a userId as a prop in the component. And we also put that into a dependency array. Dependency means the things that gets modified triggers a re run onÂ effect.</p>\n<p>For a specific userId the effect will synchronize with the component. But if we modify the userId and call the component, It will disconnect the effect from the old userId and synchronize the effect with a newÂ userId.</p>\n<p>The body of the effect specifies how to start synchronizing and the cleanup function specifies how to stop synchronizing.</p>\n<p>For example, you called the component with userId 1. It will start synchronizing the component with effect with the value of 1. The moment you change it to 2, the cleanup function will run and the effect and the component will be synchronized with valueÂ 2.</p>\n<p>So, the effect will run if and onlyÂ if</p>\n<blockquote><strong>the userId changes, not the windowWidth. Because userId is in the dependency array, windowWidth isÂ not.</strong></blockquote>\n<p>If there would have been multple elements in the dependency array, modification of atleast a single element will be enough to re run theÂ effect.</p>\n<h3>How React Handles Dependency Array</h3>\n<p>If you configure your linter for React, it will tell you about the dependencies required to be put inside the dependency array.</p>\n<pre>import React, { useState, useEffect } from 'react';<br><br>function WindowTracker({userId}) {<br>  const [windowWidth, setWindowWidth] = useState(window.innerWidth);<br>  const value = 123<br><br>  useEffect(() =&gt; {<br>    function handleResize() {<br>      console.log('Window was resized!');<br>      setWindowWidth(window.innerWidth);<br>    }<br><br>    window.addEventListener('resize', handleResize);    <br>    console.log('Event listener added.');<br><br>    // cleanup<br>    return () =&gt; {<br>      window.removeEventListener('resize', handleResize);<br>      console.log('Event listener removed. Cleanup complete!');<br>    };<br><br>  }, []); // The editor will suggest you to put userId in the dependencey array<br><br>  return (<br>    &lt;div&gt;<br>      &lt;h2&gt;Resize the browser window ğŸ“&lt;/h2&gt;<br>      &lt;p&gt;Current window width: {windowWidth}px&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>export default WindowTracker;</pre>\n<p>The code will run smoothly. However, the editor will suggest you put userId in the dependency array. As, modifying it will re run theÂ effect.</p>\n<p>We can put the value variable in the dependency array. Still the code will run smoothly. But the editor will warn you not to add it. Why? because the value of value does not change in a re-render. You can put it in the dependency array, but as it will not change. The effect will run during the firstÂ mount.</p>\n<h3>Summary</h3>\n<ol>\n<li>Components mount, update andÂ unmount</li>\n<li>Effects have seperate lifecycles than the components</li>\n<li>Each effect can have seperate synchronization process that can start andÂ stop</li>\n<li>Each effect will have its own perspective of synchronization, that does not depend on any other effects in same component or the component itself</li>\n<li>Values declared inside the component body are â€œreactiveâ€</li>\n<li>Reactive values should re-synchronize the Effect because they can change overÂ time.</li>\n<li>The linter verifies that all reactive values used inside the Effect are specified as dependencies.</li>\n<li>All errors flagged by the linter are legitimate. Thereâ€™s always a way to fix the code to not break theÂ rules.</li>\n</ol>\n<h3>A message from ourÂ Founder</h3>\n<p><strong>Hey, </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>Sunil</strong></a><strong> here.</strong> I wanted to take a moment to thank you for reading until the end and for being a part of this community.</p>\n<p>Did you know that our team run these publications as a volunteer effort to over 3.5m monthly readers? <strong>We donâ€™t receive any funding, we do this to support the community. â¤ï¸</strong></p>\n<p>If you want to show some love, please take a moment to <strong>follow me on </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>LinkedIn</strong></a><strong>, </strong><a href=\"https://tiktok.com/@messyfounder\"><strong>TikTok</strong></a>, <a href=\"https://instagram.com/sunilsandhu\"><strong>Instagram</strong></a>. You can also subscribe to our <a href=\"https://newsletter.plainenglish.io/\"><strong>weekly newsletter</strong></a>.</p>\n<p>And before you go, donâ€™t forget to <strong>clap</strong> and <strong>follow</strong> theÂ writerï¸!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c2b421cbf58e\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://javascript.plainenglish.io/deep-dive-into-effects-in-react-c2b421cbf58e\">Deep Dive into Effects in React</a> was originally published in <a href=\"https://javascript.plainenglish.io/\">JavaScript in Plain English</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "enclosure": {},
    "categories": ["reactjs", "useeffect"]
  },
  {
    "title": "State Modification in React, What Happens Behind the Scene",
    "pubDate": "2025-09-14 05:18:51",
    "link": "https://javascript.plainenglish.io/state-modification-in-react-what-happens-behind-the-scene-20aa0af679ff?source=rss-eea2b02f8c4c------2",
    "guid": "https://medium.com/p/20aa0af679ff",
    "author": "Serajur Reza Chowdhury",
    "thumbnail": "",
    "description": "\n<p>Can you tell me why React is called <strong>React</strong>. Because it reacts. When ever something that belongs to the component changes or any side effect occurs, it re-renders. Which means it reacts. Now there is something that can belong to one specific component only, which means it cannot be used by any other component. Now change of that thing a number, a boolean, an object, an array can cause rendering a component or react. This is called state. Now you understand what state is, letâ€™s get deep dive intoÂ it.</p>\n<h3>React States</h3>\n<p>The variable that belongs to a specfic component is called state. It is a property of the component itself. It cannot be declared randomly inside a component. It follows a rule and it is likeÂ this,</p>\n<p>First you have to import the useState from the core ReactÂ library,</p>\n<pre>import {useState} from 'react'</pre>\n<p>Then create a functional component,</p>\n<pre>function Counter(){<br>  return (<br>    &lt;div&gt;<br>        &lt;div&gt;{count}&lt;/div&gt;<br>        &lt;button&gt;+&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre>\n<p>Then declare a state like this inside the component,</p>\n<pre>const [count, setCount] = useState(0)</pre>\n<p>The component will look likeÂ this,</p>\n<pre>import {useState} from 'react'<br><br>function Counter(){<br>  const [count, setCount] = useState(0)<br><br>  const handleCount = () =&gt;{<br>    setCount(count + 1)<br>  }<br>  return (<br>    &lt;div&gt;<br>        &lt;div&gt;{count}&lt;/div&gt;<br>        &lt;button onClick={handleCount}&gt;+&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre>\n<p>Declaring state follows array destructuring feature from js, the first variable is the state value itself, and the second one is the handler which modifies the state. The useState hook takes the initial value as a parameter. Here, it isÂ 0.</p>\n<h3>Behind theÂ Scenes</h3>\n<p>For this scenario, when you click the button, the setCount function invokes, it adds 1 to the count variable and updates the count value. As the state updates, the Counter component re-renders.</p>\n<p>As you have called the setCount once inside the buttonâ€™s onClick function. You will see that the count increases by 1 in eachÂ click.</p>\n<p>Letâ€™s change the event handler a littleÂ bit,</p>\n<pre>import {useState} from 'react'<br><br>function Counter(){<br>  const [count, setCount] = useState(0)<br><br>  const handleCount = () =&gt;{<br>    setCount(count + 1)<br>    alert(count)<br>  }<br>  return (<br>    &lt;div&gt;<br>        &lt;div&gt;{count}&lt;/div&gt;<br>        &lt;button onClick={handleCount}&gt;+&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre>\n<p>If you click on the button, and after the setCount functions are executed, you will see value of count is 0 on alert.Â Why?</p>\n<p>Inside the handleCount function, we called the setCount function. Calling this causes a render. Rendering means calling the component. In this case, the Counter function is called. When the function/component is called, all the functions, event handlers, jsx are calculated based on current state value, not the updated state value. Then the state updates, and the changed state is reflected in the jsx. The returned jsx is interactive, which means it can reflect the changes inside the component.</p>\n<p>So, these happened when do something that changes theÂ state.</p>\n<ol>\n<li>The component is called/Â rendered</li>\n<li>The component returns a snapshot/screenshot of the jsx insideÂ it</li>\n<li>React updates the state and reflect changes inside theÂ jsx</li>\n</ol>\n<p>Letâ€™s see anotherÂ case,</p>\n<pre>import {useState} from 'react'<br><br>function Counter(){<br>  const [count, setCount] = useState(0)<br><br>  const handleCount = () =&gt;{<br>    setCount(count + 1)<br>    setTimeout(() =&gt; {<br>      alert(count)<br>    }, 3000);<br>  }<br>  return (<br>    &lt;div&gt;<br>        &lt;div&gt;{count}&lt;/div&gt;<br>        &lt;button onClick={handleCount}&gt;+&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre>\n<p>Youâ€™ll see the same result if you run this code. The difference is that the alert will occur 3 secondsÂ later.</p>\n<p>A stateâ€™s value never changes during a render, even if handlerâ€™s code is asynchronous. When the setCount was called, the value of count is 0 when the render occured. So, the alert showsÂ 0.</p>\n<p>You will often hear that, state change is asynchronous, which means changes does not reflect immediately after changing the state. This is actually how changing state works behind theÂ scene.</p>\n<blockquote>React keeps the state values â€œfixedâ€ within one renderâ€™s event handlers.</blockquote>\n<p>So, if we recap, we will get the following points,</p>\n<ol>\n<li>Changing state causes a newÂ render</li>\n<li>React creates a snapshot/ calculates functions, handlers, jsx of the state with its current value if changing state is triggered. (Here it is setCount and theÂ current)</li>\n<li>Variables and event handlers donâ€™t â€œsurviveâ€ re-renders. Every render has its own event handlers.</li>\n<li>Every render (and functions inside it) will always â€œseeâ€ the current state value of the state (value before changing state) that React gave to <em>that</em>Â render.</li>\n<li>Event handlers created in the past have the state values (value before changing state) from the render in which they wereÂ created.</li>\n</ol>\n<p>Thatâ€™s all for how state changing states works behind theÂ scenes.</p>\n<h3>A message from ourÂ Founder</h3>\n<p><strong>Hey, </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>Sunil</strong></a><strong> here.</strong> I wanted to take a moment to thank you for reading until the end and for being a part of this community.</p>\n<p>Did you know that our team run these publications as a volunteer effort to over 3.5m monthly readers? <strong>We donâ€™t receive any funding, we do this to support the community. â¤ï¸</strong></p>\n<p>If you want to show some love, please take a moment to <strong>follow me on </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>LinkedIn</strong></a><strong>, </strong><a href=\"https://tiktok.com/@messyfounder\"><strong>TikTok</strong></a>, <a href=\"https://instagram.com/sunilsandhu\"><strong>Instagram</strong></a>. You can also subscribe to our <a href=\"https://newsletter.plainenglish.io/\"><strong>weekly newsletter</strong></a>.</p>\n<p>And before you go, donâ€™t forget to <strong>clap</strong> and <strong>follow</strong> theÂ writerï¸!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=20aa0af679ff\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://javascript.plainenglish.io/state-modification-in-react-what-happens-behind-the-scene-20aa0af679ff\">State Modification in React, What Happens Behind the Scene</a> was originally published in <a href=\"https://javascript.plainenglish.io/\">JavaScript in Plain English</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "content": "\n<p>Can you tell me why React is called <strong>React</strong>. Because it reacts. When ever something that belongs to the component changes or any side effect occurs, it re-renders. Which means it reacts. Now there is something that can belong to one specific component only, which means it cannot be used by any other component. Now change of that thing a number, a boolean, an object, an array can cause rendering a component or react. This is called state. Now you understand what state is, letâ€™s get deep dive intoÂ it.</p>\n<h3>React States</h3>\n<p>The variable that belongs to a specfic component is called state. It is a property of the component itself. It cannot be declared randomly inside a component. It follows a rule and it is likeÂ this,</p>\n<p>First you have to import the useState from the core ReactÂ library,</p>\n<pre>import {useState} from 'react'</pre>\n<p>Then create a functional component,</p>\n<pre>function Counter(){<br>  return (<br>    &lt;div&gt;<br>        &lt;div&gt;{count}&lt;/div&gt;<br>        &lt;button&gt;+&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre>\n<p>Then declare a state like this inside the component,</p>\n<pre>const [count, setCount] = useState(0)</pre>\n<p>The component will look likeÂ this,</p>\n<pre>import {useState} from 'react'<br><br>function Counter(){<br>  const [count, setCount] = useState(0)<br><br>  const handleCount = () =&gt;{<br>    setCount(count + 1)<br>  }<br>  return (<br>    &lt;div&gt;<br>        &lt;div&gt;{count}&lt;/div&gt;<br>        &lt;button onClick={handleCount}&gt;+&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre>\n<p>Declaring state follows array destructuring feature from js, the first variable is the state value itself, and the second one is the handler which modifies the state. The useState hook takes the initial value as a parameter. Here, it isÂ 0.</p>\n<h3>Behind theÂ Scenes</h3>\n<p>For this scenario, when you click the button, the setCount function invokes, it adds 1 to the count variable and updates the count value. As the state updates, the Counter component re-renders.</p>\n<p>As you have called the setCount once inside the buttonâ€™s onClick function. You will see that the count increases by 1 in eachÂ click.</p>\n<p>Letâ€™s change the event handler a littleÂ bit,</p>\n<pre>import {useState} from 'react'<br><br>function Counter(){<br>  const [count, setCount] = useState(0)<br><br>  const handleCount = () =&gt;{<br>    setCount(count + 1)<br>    alert(count)<br>  }<br>  return (<br>    &lt;div&gt;<br>        &lt;div&gt;{count}&lt;/div&gt;<br>        &lt;button onClick={handleCount}&gt;+&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre>\n<p>If you click on the button, and after the setCount functions are executed, you will see value of count is 0 on alert.Â Why?</p>\n<p>Inside the handleCount function, we called the setCount function. Calling this causes a render. Rendering means calling the component. In this case, the Counter function is called. When the function/component is called, all the functions, event handlers, jsx are calculated based on current state value, not the updated state value. Then the state updates, and the changed state is reflected in the jsx. The returned jsx is interactive, which means it can reflect the changes inside the component.</p>\n<p>So, these happened when do something that changes theÂ state.</p>\n<ol>\n<li>The component is called/Â rendered</li>\n<li>The component returns a snapshot/screenshot of the jsx insideÂ it</li>\n<li>React updates the state and reflect changes inside theÂ jsx</li>\n</ol>\n<p>Letâ€™s see anotherÂ case,</p>\n<pre>import {useState} from 'react'<br><br>function Counter(){<br>  const [count, setCount] = useState(0)<br><br>  const handleCount = () =&gt;{<br>    setCount(count + 1)<br>    setTimeout(() =&gt; {<br>      alert(count)<br>    }, 3000);<br>  }<br>  return (<br>    &lt;div&gt;<br>        &lt;div&gt;{count}&lt;/div&gt;<br>        &lt;button onClick={handleCount}&gt;+&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>}</pre>\n<p>Youâ€™ll see the same result if you run this code. The difference is that the alert will occur 3 secondsÂ later.</p>\n<p>A stateâ€™s value never changes during a render, even if handlerâ€™s code is asynchronous. When the setCount was called, the value of count is 0 when the render occured. So, the alert showsÂ 0.</p>\n<p>You will often hear that, state change is asynchronous, which means changes does not reflect immediately after changing the state. This is actually how changing state works behind theÂ scene.</p>\n<blockquote>React keeps the state values â€œfixedâ€ within one renderâ€™s event handlers.</blockquote>\n<p>So, if we recap, we will get the following points,</p>\n<ol>\n<li>Changing state causes a newÂ render</li>\n<li>React creates a snapshot/ calculates functions, handlers, jsx of the state with its current value if changing state is triggered. (Here it is setCount and theÂ current)</li>\n<li>Variables and event handlers donâ€™t â€œsurviveâ€ re-renders. Every render has its own event handlers.</li>\n<li>Every render (and functions inside it) will always â€œseeâ€ the current state value of the state (value before changing state) that React gave to <em>that</em>Â render.</li>\n<li>Event handlers created in the past have the state values (value before changing state) from the render in which they wereÂ created.</li>\n</ol>\n<p>Thatâ€™s all for how state changing states works behind theÂ scenes.</p>\n<h3>A message from ourÂ Founder</h3>\n<p><strong>Hey, </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>Sunil</strong></a><strong> here.</strong> I wanted to take a moment to thank you for reading until the end and for being a part of this community.</p>\n<p>Did you know that our team run these publications as a volunteer effort to over 3.5m monthly readers? <strong>We donâ€™t receive any funding, we do this to support the community. â¤ï¸</strong></p>\n<p>If you want to show some love, please take a moment to <strong>follow me on </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>LinkedIn</strong></a><strong>, </strong><a href=\"https://tiktok.com/@messyfounder\"><strong>TikTok</strong></a>, <a href=\"https://instagram.com/sunilsandhu\"><strong>Instagram</strong></a>. You can also subscribe to our <a href=\"https://newsletter.plainenglish.io/\"><strong>weekly newsletter</strong></a>.</p>\n<p>And before you go, donâ€™t forget to <strong>clap</strong> and <strong>follow</strong> theÂ writerï¸!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=20aa0af679ff\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://javascript.plainenglish.io/state-modification-in-react-what-happens-behind-the-scene-20aa0af679ff\">State Modification in React, What Happens Behind the Scene</a> was originally published in <a href=\"https://javascript.plainenglish.io/\">JavaScript in Plain English</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "enclosure": {},
    "categories": ["reactjs", "state-management"]
  },
  {
    "title": "Intercepting and Parallel Routes in Next.js",
    "pubDate": "2025-08-30 09:05:15",
    "link": "https://javascript.plainenglish.io/intercepting-and-parallel-routes-in-next-js-107e4773ce7d?source=rss-eea2b02f8c4c------2",
    "guid": "https://medium.com/p/107e4773ce7d",
    "author": "Serajur Reza Chowdhury",
    "thumbnail": "",
    "description": "\n<p>Ever wondering if you click on a image and a new link generates and the image opens in a modal. And then you refresh the page and the modal turns into a web page. The same weird case can happen for the signup or login form, for a single product in an ecommerce site or for a single blog in a blog application. Yes, Next js offers this extraordinary feature through parallel and intercepting route. Letâ€™s get deep dive intoÂ it.</p>\n<h3>What is Parallel and Intercepting route</h3>\n<p>Parallel routes helps you to simultaneously or conditionally render one or more pages in the same layout. For dynamic sections, it can be very useful such as a product in an ecommerce site, a single blog in a blogÂ site.</p>\n<p>The convention is you need to create a slot like this where you want to create a parallel route like this, @modal. The folder structure looks likeÂ this,</p>\n<pre>@modal<br>  (.)folder<br>    page.tsx<br>  default.tsx<br>folder<br>  page.tsx</pre>\n<p>You need to create a page file in js/jsx/tsx to create parallel route. Here you can design how your page will lookÂ like.</p>\n<p>Then you need to pass this modal to the layout. As it is mentioned earlier, parallel route works inside a specific layout. You need to pass the modal as prop to the layout. The layout.tsx file looks likeÂ this.</p>\n<pre>export default function Layout({<br>  children,<br>  modal<br>}: {<br>  children: React.ReactNode<br>  modal: React.ReactNode<br>}) {<br>  return (<br>    &lt;&gt;<br>      {children}<br>      {modal}<br>    &lt;/&gt;<br>  )<br>}</pre>\n<p>In the default.tsx, you need to write thisÂ code.</p>\n<pre>export default function DefaultModal() {<br>  return null;<br>}</pre>\n<p>This works as a suspense. For reload/unmatched routes/outside of your layout this modal will not work. It will then render the wholeÂ webpage.</p>\n<p>Did you notice the (.)folder? This is actually intercepting route. The @modal, will intercept the route from the (.)folder route, and show a modal from the (.)folder route.</p>\n<p>Intercepting route helps load a route from another part of an application to the currentÂ layout.</p>\n<p>Intercepting routes can be defined with the (.) convention, same as relative path convention.</p>\n<p>Some examples canÂ be,</p>\n<pre>(.) to match segments on the same level (same level as @modal and folder)<br>(..) to match segments one level above (folder is one level above @modal)<br>(..)(..) to match segments two levels above (folder is two levels above @modal)<br>(...) to match segments from the root app directory</pre>\n<p>In our example, our folder and @modal, is on the same level, so we used (.)folder convention. If @modal, was one level inside the folder, we would use (..)folder convention.</p>\n<blockquote><strong>One very important thing to keep in mind, the parallel route folder @modal, and layout.tsx should be from the same level. Because this modal will work as a child component in theÂ layout.</strong></blockquote>\n<h3><strong>Creating theÂ project</strong></h3>\n<p>We will be using next js 15 for this tutorial. Just copy this command to your commandÂ line.</p>\n<pre>npx create-next-app@latest</pre>\n<p>Then choose the select the following options</p>\n<pre>npx create-next-app@latest<br>Need to install the following packages:<br>create-next-app@15.5.2<br>Ok to proceed? (y) y<br><br>âˆš What is your project named? ... next-interceptor<br>âˆš Would you like to use TypeScript? ... Yes<br>âˆš Which linter would you like to use? Â» ESLint<br>âˆš Would you like to use Tailwind CSS? ... Yes<br>âˆš Would you like your code inside a `src/` directory? ... Yes<br>âˆš Would you like to use App Router? (recommended) ... Yes<br>âˆš Would you like to use Turbopack? (recommended) ... Yes<br>âˆš Would you like to customize the import alias (`@/*` by default)? ... No</pre>\n<p>Our project folder structure looks likeÂ this,</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/342/1*kdKTDLMVCiHL6qRSs8i3XQ.png\"><figcaption>Folder Structure</figcaption></figure><h3>Deep Dive into Parallel and Intercepting Route</h3>\n<p>As we will intercept our route with a modal, so we will design a modal first. So, letâ€™s create a modal inside the components folder, outside the appÂ folder.</p>\n<pre>\"use client\";<br>import { useRouter } from \"next/navigation\";<br>import { useCallback, useEffect, useRef } from \"react\";<br><br>export default function Modal({ children }) {<br>  const overlay = useRef(null);<br>  const wrapper = useRef(null);<br>  const router = useRouter();<br><br>  const onDismiss = useCallback(() =&gt; {<br>    router.back();<br>  }, [router]);<br><br>  const onClick = useCallback(<br>    (e) =&gt; {<br>      if (e.target === overlay.current || e.target === wrapper.current) {<br>        if (onDismiss) onDismiss();<br>      }<br>    },<br>    [onDismiss, overlay, wrapper]<br>  );<br><br>  const onKeyDown = useCallback(<br>    (e) =&gt; {<br>      if (e.key === \"Escape\") onDismiss();<br>    },<br>    [onDismiss]<br>  );<br><br>  useEffect(() =&gt; {<br>    document.addEventListener(\"keydown\", onKeyDown);<br>    return () =&gt; document.removeEventListener(\"keydown\", onKeyDown);<br>  }, [onKeyDown]);<br><br>  return (<br>    &lt;div<br>      ref={overlay}<br>      className=\"fixed inset-0 bg-black/50 h-screen z-50\"<br>      onClick={onClick}<br>    &gt;<br>      &lt;article<br>        ref={wrapper}<br>        className=\"max-w-4xl mx-auto h-screen px-4 pb-8 bg-white text-black rounded-md shadow-lg relative z-50 mt-8 overflow-scroll\"<br>      &gt;<br>        {children}<br>      &lt;/article&gt;<br>    &lt;/div&gt;<br>  );<br>}</pre>\n<p>Next we will create a images folder where we will export images for our project. The images will be kept inside the imagesÂ folder.</p>\n<pre>import download1 from \"@/images/download (1).jpeg\";<br>import download from \"@/images/download.jpeg\";<br>import radioactive from \"@/images/radioactive.jpg\";<br>import react from \"@/images/react.png\";<br><br>const images = [<br>  {<br>    id: \"1\",<br>    name: \"download1\",<br>    src: download1,<br>  },<br>  {<br>    id: \"2\",<br>    name: \"download\",<br>    src: download,<br>  },<br>  {<br>    id: \"3\",<br>    name: \"react\",<br>    src: react,<br>  },<br>  {<br>    id: \"4\",<br>    name: \"radioactive\",<br>    src: radioactive,<br>  },<br>];<br><br>export default images;</pre>\n<p>Next we will design the home page where we will show all the images. Inside the page.tsxÂ file,</p>\n<pre>import images from \"@/images\";<br>import Image from \"next/image\";<br>import Link from \"next/link\";<br><br>export default function Home() {<br>  return (<br>    &lt;div className=\"container mx-auto p-4\"&gt;<br>      &lt;div className=\"grid grid-cols-1 md:grid-cols-4 gap-4\"&gt;<br>        {images.map(({ id, src, name }) =&gt; (<br>          &lt;Link key={id} href={`/image/${id}`}&gt;<br>            &lt;Image<br>              alt={name}<br>              src={src}<br>              className=\"w-full object-cover aspect-square\"<br>            /&gt;<br>          &lt;/Link&gt;<br>        ))}<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  );<br>}</pre>\n<p>We will then generate seperate pages for every image. We will create a images folder. Inside it we will create a [id] folder, which represents the unique id of the image. Inside it create page.tsx file to view an image in a seperateÂ webpage.</p>\n<pre>import images from \"@/images\";<br>import Image from \"next/image\";<br>import React from \"react\";<br><br>export default function SingleImage({ params }) {<br>  const { id } = params;<br>  const image = images.find((p) =&gt; p.id === id);<br><br>  return (<br>    &lt;div className=\"container mx-auto my-10\"&gt;<br>      &lt;div className=\"w-1/2 mx-auto\"&gt;<br>        &lt;Image<br>          alt={image?.name}<br>          src={image?.src}<br>          className=\"w-full object-cover aspect-square \"<br>        /&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  );<br>}</pre>\n<p>We will create a parallel route for modal in our app folder. The name will be @modal. Inside it we will intercept the images folder with a specific id. Inside the @modal, file we will create an (.)images folder, which will intercept the images route. Inside the (.)images folder we will create the [id] folder which will have a page.tsx file. Inside the page.tsx in the intercepted route it will lookÂ like,</p>\n<pre>import Modal from \"@/components/Modal\";<br>import images from \"@/images\";<br>import Image from \"next/image\";<br>import React from \"react\";<br><br>export default function SingleImage({ params }) {<br>  const { id } = params;<br>  const image = images.find((p) =&gt; p.id === id);<br><br>  return (<br>    &lt;Modal&gt;<br>      {\" \"}<br>      &lt;div className=\"container mx-auto my-10\"&gt;<br>        &lt;div className=\"w-1/2 mx-auto\"&gt;<br>          &lt;Image<br>            alt={image?.name}<br>            src={image?.src}<br>            className=\"w-full object-cover aspect-square \"<br>          /&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/Modal&gt;<br>  );<br>}</pre>\n<p>Add a default.tsx file inside @modal, file and it will look likeÂ this,</p>\n<pre>export default function DefaultModal() {<br>  return null;<br>}</pre>\n<p>Add the modal as child in layout.tsx</p>\n<pre>export default function RootLayout({<br>  children,<br>  modal,<br>}: Readonly&lt;{<br>  children: React.ReactNode;<br>  modal: React.ReactNode;<br>}&gt;) {<br>  return (<br>    &lt;html lang=\"en\"&gt;<br>      &lt;body<br>        className={`${geistSans.variable} ${geistMono.variable} antialiased`}<br>      &gt;<br>        {children}<br>        {modal}<br>      &lt;/body&gt;<br>    &lt;/html&gt;<br>  );<br>}</pre>\n<p>Phew, finally we implemented parallel and intercepted routing in nextÂ js.</p>\n<h3>A message from ourÂ Founder</h3>\n<p><strong>Hey, </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>Sunil</strong></a><strong> here.</strong> I wanted to take a moment to thank you for reading until the end and for being a part of this community.</p>\n<p>Did you know that our team run these publications as a volunteer effort to over 3.5m monthly readers? <strong>We donâ€™t receive any funding, we do this to support the community. â¤ï¸</strong></p>\n<p>If you want to show some love, please take a moment to <strong>follow me on </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>LinkedIn</strong></a><strong>, </strong><a href=\"https://tiktok.com/@messyfounder\"><strong>TikTok</strong></a>, <a href=\"https://instagram.com/sunilsandhu\"><strong>Instagram</strong></a>. You can also subscribe to our <a href=\"https://newsletter.plainenglish.io/\"><strong>weekly newsletter</strong></a>.</p>\n<p>And before you go, donâ€™t forget to <strong>clap</strong> and <strong>follow</strong> theÂ writerï¸!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=107e4773ce7d\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://javascript.plainenglish.io/intercepting-and-parallel-routes-in-next-js-107e4773ce7d\">Intercepting and Parallel Routes in Next.js</a> was originally published in <a href=\"https://javascript.plainenglish.io/\">JavaScript in Plain English</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "content": "\n<p>Ever wondering if you click on a image and a new link generates and the image opens in a modal. And then you refresh the page and the modal turns into a web page. The same weird case can happen for the signup or login form, for a single product in an ecommerce site or for a single blog in a blog application. Yes, Next js offers this extraordinary feature through parallel and intercepting route. Letâ€™s get deep dive intoÂ it.</p>\n<h3>What is Parallel and Intercepting route</h3>\n<p>Parallel routes helps you to simultaneously or conditionally render one or more pages in the same layout. For dynamic sections, it can be very useful such as a product in an ecommerce site, a single blog in a blogÂ site.</p>\n<p>The convention is you need to create a slot like this where you want to create a parallel route like this, @modal. The folder structure looks likeÂ this,</p>\n<pre>@modal<br>  (.)folder<br>    page.tsx<br>  default.tsx<br>folder<br>  page.tsx</pre>\n<p>You need to create a page file in js/jsx/tsx to create parallel route. Here you can design how your page will lookÂ like.</p>\n<p>Then you need to pass this modal to the layout. As it is mentioned earlier, parallel route works inside a specific layout. You need to pass the modal as prop to the layout. The layout.tsx file looks likeÂ this.</p>\n<pre>export default function Layout({<br>  children,<br>  modal<br>}: {<br>  children: React.ReactNode<br>  modal: React.ReactNode<br>}) {<br>  return (<br>    &lt;&gt;<br>      {children}<br>      {modal}<br>    &lt;/&gt;<br>  )<br>}</pre>\n<p>In the default.tsx, you need to write thisÂ code.</p>\n<pre>export default function DefaultModal() {<br>  return null;<br>}</pre>\n<p>This works as a suspense. For reload/unmatched routes/outside of your layout this modal will not work. It will then render the wholeÂ webpage.</p>\n<p>Did you notice the (.)folder? This is actually intercepting route. The @modal, will intercept the route from the (.)folder route, and show a modal from the (.)folder route.</p>\n<p>Intercepting route helps load a route from another part of an application to the currentÂ layout.</p>\n<p>Intercepting routes can be defined with the (.) convention, same as relative path convention.</p>\n<p>Some examples canÂ be,</p>\n<pre>(.) to match segments on the same level (same level as @modal and folder)<br>(..) to match segments one level above (folder is one level above @modal)<br>(..)(..) to match segments two levels above (folder is two levels above @modal)<br>(...) to match segments from the root app directory</pre>\n<p>In our example, our folder and @modal, is on the same level, so we used (.)folder convention. If @modal, was one level inside the folder, we would use (..)folder convention.</p>\n<blockquote><strong>One very important thing to keep in mind, the parallel route folder @modal, and layout.tsx should be from the same level. Because this modal will work as a child component in theÂ layout.</strong></blockquote>\n<h3><strong>Creating theÂ project</strong></h3>\n<p>We will be using next js 15 for this tutorial. Just copy this command to your commandÂ line.</p>\n<pre>npx create-next-app@latest</pre>\n<p>Then choose the select the following options</p>\n<pre>npx create-next-app@latest<br>Need to install the following packages:<br>create-next-app@15.5.2<br>Ok to proceed? (y) y<br><br>âˆš What is your project named? ... next-interceptor<br>âˆš Would you like to use TypeScript? ... Yes<br>âˆš Which linter would you like to use? Â» ESLint<br>âˆš Would you like to use Tailwind CSS? ... Yes<br>âˆš Would you like your code inside a `src/` directory? ... Yes<br>âˆš Would you like to use App Router? (recommended) ... Yes<br>âˆš Would you like to use Turbopack? (recommended) ... Yes<br>âˆš Would you like to customize the import alias (`@/*` by default)? ... No</pre>\n<p>Our project folder structure looks likeÂ this,</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/342/1*kdKTDLMVCiHL6qRSs8i3XQ.png\"><figcaption>Folder Structure</figcaption></figure><h3>Deep Dive into Parallel and Intercepting Route</h3>\n<p>As we will intercept our route with a modal, so we will design a modal first. So, letâ€™s create a modal inside the components folder, outside the appÂ folder.</p>\n<pre>\"use client\";<br>import { useRouter } from \"next/navigation\";<br>import { useCallback, useEffect, useRef } from \"react\";<br><br>export default function Modal({ children }) {<br>  const overlay = useRef(null);<br>  const wrapper = useRef(null);<br>  const router = useRouter();<br><br>  const onDismiss = useCallback(() =&gt; {<br>    router.back();<br>  }, [router]);<br><br>  const onClick = useCallback(<br>    (e) =&gt; {<br>      if (e.target === overlay.current || e.target === wrapper.current) {<br>        if (onDismiss) onDismiss();<br>      }<br>    },<br>    [onDismiss, overlay, wrapper]<br>  );<br><br>  const onKeyDown = useCallback(<br>    (e) =&gt; {<br>      if (e.key === \"Escape\") onDismiss();<br>    },<br>    [onDismiss]<br>  );<br><br>  useEffect(() =&gt; {<br>    document.addEventListener(\"keydown\", onKeyDown);<br>    return () =&gt; document.removeEventListener(\"keydown\", onKeyDown);<br>  }, [onKeyDown]);<br><br>  return (<br>    &lt;div<br>      ref={overlay}<br>      className=\"fixed inset-0 bg-black/50 h-screen z-50\"<br>      onClick={onClick}<br>    &gt;<br>      &lt;article<br>        ref={wrapper}<br>        className=\"max-w-4xl mx-auto h-screen px-4 pb-8 bg-white text-black rounded-md shadow-lg relative z-50 mt-8 overflow-scroll\"<br>      &gt;<br>        {children}<br>      &lt;/article&gt;<br>    &lt;/div&gt;<br>  );<br>}</pre>\n<p>Next we will create a images folder where we will export images for our project. The images will be kept inside the imagesÂ folder.</p>\n<pre>import download1 from \"@/images/download (1).jpeg\";<br>import download from \"@/images/download.jpeg\";<br>import radioactive from \"@/images/radioactive.jpg\";<br>import react from \"@/images/react.png\";<br><br>const images = [<br>  {<br>    id: \"1\",<br>    name: \"download1\",<br>    src: download1,<br>  },<br>  {<br>    id: \"2\",<br>    name: \"download\",<br>    src: download,<br>  },<br>  {<br>    id: \"3\",<br>    name: \"react\",<br>    src: react,<br>  },<br>  {<br>    id: \"4\",<br>    name: \"radioactive\",<br>    src: radioactive,<br>  },<br>];<br><br>export default images;</pre>\n<p>Next we will design the home page where we will show all the images. Inside the page.tsxÂ file,</p>\n<pre>import images from \"@/images\";<br>import Image from \"next/image\";<br>import Link from \"next/link\";<br><br>export default function Home() {<br>  return (<br>    &lt;div className=\"container mx-auto p-4\"&gt;<br>      &lt;div className=\"grid grid-cols-1 md:grid-cols-4 gap-4\"&gt;<br>        {images.map(({ id, src, name }) =&gt; (<br>          &lt;Link key={id} href={`/image/${id}`}&gt;<br>            &lt;Image<br>              alt={name}<br>              src={src}<br>              className=\"w-full object-cover aspect-square\"<br>            /&gt;<br>          &lt;/Link&gt;<br>        ))}<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  );<br>}</pre>\n<p>We will then generate seperate pages for every image. We will create a images folder. Inside it we will create a [id] folder, which represents the unique id of the image. Inside it create page.tsx file to view an image in a seperateÂ webpage.</p>\n<pre>import images from \"@/images\";<br>import Image from \"next/image\";<br>import React from \"react\";<br><br>export default function SingleImage({ params }) {<br>  const { id } = params;<br>  const image = images.find((p) =&gt; p.id === id);<br><br>  return (<br>    &lt;div className=\"container mx-auto my-10\"&gt;<br>      &lt;div className=\"w-1/2 mx-auto\"&gt;<br>        &lt;Image<br>          alt={image?.name}<br>          src={image?.src}<br>          className=\"w-full object-cover aspect-square \"<br>        /&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  );<br>}</pre>\n<p>We will create a parallel route for modal in our app folder. The name will be @modal. Inside it we will intercept the images folder with a specific id. Inside the @modal, file we will create an (.)images folder, which will intercept the images route. Inside the (.)images folder we will create the [id] folder which will have a page.tsx file. Inside the page.tsx in the intercepted route it will lookÂ like,</p>\n<pre>import Modal from \"@/components/Modal\";<br>import images from \"@/images\";<br>import Image from \"next/image\";<br>import React from \"react\";<br><br>export default function SingleImage({ params }) {<br>  const { id } = params;<br>  const image = images.find((p) =&gt; p.id === id);<br><br>  return (<br>    &lt;Modal&gt;<br>      {\" \"}<br>      &lt;div className=\"container mx-auto my-10\"&gt;<br>        &lt;div className=\"w-1/2 mx-auto\"&gt;<br>          &lt;Image<br>            alt={image?.name}<br>            src={image?.src}<br>            className=\"w-full object-cover aspect-square \"<br>          /&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/Modal&gt;<br>  );<br>}</pre>\n<p>Add a default.tsx file inside @modal, file and it will look likeÂ this,</p>\n<pre>export default function DefaultModal() {<br>  return null;<br>}</pre>\n<p>Add the modal as child in layout.tsx</p>\n<pre>export default function RootLayout({<br>  children,<br>  modal,<br>}: Readonly&lt;{<br>  children: React.ReactNode;<br>  modal: React.ReactNode;<br>}&gt;) {<br>  return (<br>    &lt;html lang=\"en\"&gt;<br>      &lt;body<br>        className={`${geistSans.variable} ${geistMono.variable} antialiased`}<br>      &gt;<br>        {children}<br>        {modal}<br>      &lt;/body&gt;<br>    &lt;/html&gt;<br>  );<br>}</pre>\n<p>Phew, finally we implemented parallel and intercepted routing in nextÂ js.</p>\n<h3>A message from ourÂ Founder</h3>\n<p><strong>Hey, </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>Sunil</strong></a><strong> here.</strong> I wanted to take a moment to thank you for reading until the end and for being a part of this community.</p>\n<p>Did you know that our team run these publications as a volunteer effort to over 3.5m monthly readers? <strong>We donâ€™t receive any funding, we do this to support the community. â¤ï¸</strong></p>\n<p>If you want to show some love, please take a moment to <strong>follow me on </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>LinkedIn</strong></a><strong>, </strong><a href=\"https://tiktok.com/@messyfounder\"><strong>TikTok</strong></a>, <a href=\"https://instagram.com/sunilsandhu\"><strong>Instagram</strong></a>. You can also subscribe to our <a href=\"https://newsletter.plainenglish.io/\"><strong>weekly newsletter</strong></a>.</p>\n<p>And before you go, donâ€™t forget to <strong>clap</strong> and <strong>follow</strong> theÂ writerï¸!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=107e4773ce7d\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://javascript.plainenglish.io/intercepting-and-parallel-routes-in-next-js-107e4773ce7d\">Intercepting and Parallel Routes in Next.js</a> was originally published in <a href=\"https://javascript.plainenglish.io/\">JavaScript in Plain English</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "enclosure": {},
    "categories": ["nextjs", "routing"]
  },
  {
    "title": "Is it necessary to use Redux in React Applications?",
    "pubDate": "2025-08-19 12:46:04",
    "link": "https://javascript.plainenglish.io/is-it-neccessary-to-use-redux-in-react-applications-1b9fedbea4d6?source=rss-eea2b02f8c4c------2",
    "guid": "https://medium.com/p/1b9fedbea4d6",
    "author": "Serajur Reza Chowdhury",
    "thumbnail": "",
    "description": "\n<p>Most of the cases we use redux for two purposes. One is central state management and the other is third party api calling middleware. Now the thing is we have to write a lot of boiler plate code to configure Redux in our applications. And these are very complex to understand especially for the beginners. And we have to use third party libraries in our React applications as it is a library and its sole purpose is to create reactive UI, nothingÂ else.</p>\n<p>But it is trying to be self-reliant day by day. So, for that we may not need redux for the future. For the central state management, where the state can be accessible anywhere inside the application, we can use context api. Redux uses this under the hood. In Redux, we use a Provider component which takes a store as a parameter which refers to the object that can be accessible from anywhere inside the application. In context api, you can create a context and pass it to provider and make it accessible to anywhere in the application.</p>\n<p>In Redux, to change the state we have to dispatch actions. This actions works inside reducer functions which takes the initialState and action. The action has a payload property that changes the state and returns a new overriden state. We can do this with useReducer hook. Just like useState, it takes a reducer function and an initialState as a parameter. The reducer function also takes two parameters, the initialState and action. The action parameter has a payload property that changes the state and returns a new overriden state. It returns a the modified state and the action dispatcher. The same thing the redux reducerÂ returns.</p>\n<p>In context api, we can declare a variable or a state with useState, or any reducer that changes the variable and the state. wrap it inside the object and pass it in the context provider. We can also create a custom hook that returns the context wrapped inside the useContext hook. This practice will keep the code clean and restrict the state management into one file with all the reducers, actions, state insideÂ it.</p>\n<p>For third party api calling, we used to use redux thunk middleware, most recently rtk query if we use redux. RTK query is also used as a middleware. Now this syntax is also kind of messy and complex. RTK query has some features like caching, refetching, loading, errorÂ etc.</p>\n<p>React does not have any feature regarding api calling other than calling api with useEffect. Here we have to manage state such as caching, refetching, loading, error on our own with useState. Now writing too many local states is not a good idea due to rendering issues. For this react recently introduced the use hook which reads the value of a promise and context. For my opinion, it is better to use tanstack query for asynchronous server state management. Though it does not support middleware, it provides different state management like caching, refetching, loading, error etc. You donâ€™t have maintain different states to manage those. For intercepting and middleware you can use axios. It also works like context providers.</p>\n<p>So, for the developing optimized, clean code react applications I do not think redux is a must. We can do client side state management with built in react hooks, though we may have to write a few but still it will still stay clean, easy to understand and manageable. And for server side state management tanstack query is a good choice. Because of clean, manageable architecture. And the core react team is also working finding a solution for server side third party apiÂ calling.</p>\n<h3>A message from ourÂ Founder</h3>\n<p><strong>Hey, </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>Sunil</strong></a><strong> here.</strong> I wanted to take a moment to thank you for reading until the end and for being a part of this community.</p>\n<p>Did you know that our team run these publications as a volunteer effort to over 3.5m monthly readers? <strong>We donâ€™t receive any funding, we do this to support the community. â¤ï¸</strong></p>\n<p>If you want to show some love, please take a moment to <strong>follow me on </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>LinkedIn</strong></a><strong>, </strong><a href=\"https://tiktok.com/@messyfounder\"><strong>TikTok</strong></a>, <a href=\"https://instagram.com/sunilsandhu\"><strong>Instagram</strong></a>. You can also subscribe to our <a href=\"https://newsletter.plainenglish.io/\"><strong>weekly newsletter</strong></a>.</p>\n<p>And before you go, donâ€™t forget to <strong>clap</strong> and <strong>follow</strong> theÂ writerï¸!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1b9fedbea4d6\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://javascript.plainenglish.io/is-it-neccessary-to-use-redux-in-react-applications-1b9fedbea4d6\">Is it necessary to use Redux in React Applications?</a> was originally published in <a href=\"https://javascript.plainenglish.io/\">JavaScript in Plain English</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "content": "\n<p>Most of the cases we use redux for two purposes. One is central state management and the other is third party api calling middleware. Now the thing is we have to write a lot of boiler plate code to configure Redux in our applications. And these are very complex to understand especially for the beginners. And we have to use third party libraries in our React applications as it is a library and its sole purpose is to create reactive UI, nothingÂ else.</p>\n<p>But it is trying to be self-reliant day by day. So, for that we may not need redux for the future. For the central state management, where the state can be accessible anywhere inside the application, we can use context api. Redux uses this under the hood. In Redux, we use a Provider component which takes a store as a parameter which refers to the object that can be accessible from anywhere inside the application. In context api, you can create a context and pass it to provider and make it accessible to anywhere in the application.</p>\n<p>In Redux, to change the state we have to dispatch actions. This actions works inside reducer functions which takes the initialState and action. The action has a payload property that changes the state and returns a new overriden state. We can do this with useReducer hook. Just like useState, it takes a reducer function and an initialState as a parameter. The reducer function also takes two parameters, the initialState and action. The action parameter has a payload property that changes the state and returns a new overriden state. It returns a the modified state and the action dispatcher. The same thing the redux reducerÂ returns.</p>\n<p>In context api, we can declare a variable or a state with useState, or any reducer that changes the variable and the state. wrap it inside the object and pass it in the context provider. We can also create a custom hook that returns the context wrapped inside the useContext hook. This practice will keep the code clean and restrict the state management into one file with all the reducers, actions, state insideÂ it.</p>\n<p>For third party api calling, we used to use redux thunk middleware, most recently rtk query if we use redux. RTK query is also used as a middleware. Now this syntax is also kind of messy and complex. RTK query has some features like caching, refetching, loading, errorÂ etc.</p>\n<p>React does not have any feature regarding api calling other than calling api with useEffect. Here we have to manage state such as caching, refetching, loading, error on our own with useState. Now writing too many local states is not a good idea due to rendering issues. For this react recently introduced the use hook which reads the value of a promise and context. For my opinion, it is better to use tanstack query for asynchronous server state management. Though it does not support middleware, it provides different state management like caching, refetching, loading, error etc. You donâ€™t have maintain different states to manage those. For intercepting and middleware you can use axios. It also works like context providers.</p>\n<p>So, for the developing optimized, clean code react applications I do not think redux is a must. We can do client side state management with built in react hooks, though we may have to write a few but still it will still stay clean, easy to understand and manageable. And for server side state management tanstack query is a good choice. Because of clean, manageable architecture. And the core react team is also working finding a solution for server side third party apiÂ calling.</p>\n<h3>A message from ourÂ Founder</h3>\n<p><strong>Hey, </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>Sunil</strong></a><strong> here.</strong> I wanted to take a moment to thank you for reading until the end and for being a part of this community.</p>\n<p>Did you know that our team run these publications as a volunteer effort to over 3.5m monthly readers? <strong>We donâ€™t receive any funding, we do this to support the community. â¤ï¸</strong></p>\n<p>If you want to show some love, please take a moment to <strong>follow me on </strong><a href=\"https://linkedin.com/in/sunilsandhu\"><strong>LinkedIn</strong></a><strong>, </strong><a href=\"https://tiktok.com/@messyfounder\"><strong>TikTok</strong></a>, <a href=\"https://instagram.com/sunilsandhu\"><strong>Instagram</strong></a>. You can also subscribe to our <a href=\"https://newsletter.plainenglish.io/\"><strong>weekly newsletter</strong></a>.</p>\n<p>And before you go, donâ€™t forget to <strong>clap</strong> and <strong>follow</strong> theÂ writerï¸!</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1b9fedbea4d6\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://javascript.plainenglish.io/is-it-neccessary-to-use-redux-in-react-applications-1b9fedbea4d6\">Is it necessary to use Redux in React Applications?</a> was originally published in <a href=\"https://javascript.plainenglish.io/\">JavaScript in Plain English</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "enclosure": {},
    "categories": ["react", "redux"]
  },
  {
    "title": "React UseEffect As Lifecycles",
    "pubDate": "2022-11-16 12:46:25",
    "link": "https://rezainfinity54.medium.com/react-useeffect-as-lifecycles-a9eaad2bc2d?source=rss-eea2b02f8c4c------2",
    "guid": "https://medium.com/p/a9eaad2bc2d",
    "author": "Serajur Reza Chowdhury",
    "thumbnail": "",
    "description": "\n<p>If you ever check a react codebase with functional components, youâ€™ll notice two words used widely in the project. useState and useEffect. Of course if the components are functional. The work of useState is simple, creates a state and re-renders a component when it changes. But useEffect is something very strange behind the scenes. It is used for any operations while rendering a component. Such as, third party API calling, changing a state value while rendering a component etc.</p>\n<p>But useEffect does something more behind the scenes. For the functional components, it works as a substitute to the lifecycle methods, which are only available for class components. And thatâ€™s where the confusion occurs. A lot of developers use useEffect hook just to run an operation while rendering components. Here, I will describe how useEffect runs the lifecycle methods behind theÂ scenes.</p>\n<h3>The useEffect hook</h3>\n<p>The useEffect hook does the operation of three component lifecycle methods in a body. componentDidMount, componentDidUpdate and componentWillUnmount. But, we need to have ideas aboutÂ those.</p>\n<h3>componentDidMount</h3>\n<blockquote>A component <em>mounts</em> when itâ€™s added to theÂ screen.</blockquote>\n<p>componentDidMount is a lifecycle method where the component is created and inserted to the DOM. It runs when the component mounts. Here we can make API calls, changing stateÂ etc.</p>\n<pre>componentDidMount() {<br>  this.setState({<br>    loading: false<br>  })<br>}</pre>\n<h3>componentDidUpdate</h3>\n<blockquote>A component <em>updates</em> when it receives new props or state, usually in response to an interaction.</blockquote>\n<p>componentDidUpdate runs whenever a component updates. It takes the previous props and states as properties and runs if there is a mismatch between current and previous states andÂ props.</p>\n<pre>componentDidUpdate(prevProps, prevStates){<br>  if(this.props.loading !== prevProps.loading){<br>    return true<br>  }<br>}</pre>\n<p>You can decide whether you can update based on the change of props and/orÂ states.</p>\n<h3>componentWillUnmount</h3>\n<blockquote>A component <em>unmounts</em> when itâ€™s removed from theÂ screen.</blockquote>\n<p>This lifecycle runs right before the component is unmounted. Here all the subscriptions are cancelled, all the networks are disconnected and all the timers are cleared. In a nutshell, all the cleanup works are occurred in componentWillUnmount</p>\n<pre>componentDidMount(){<br>  this.interval = setInterval(()=&gt;{<br>    this.setState({<br>      seconds: seconds + 1<br>    })<br>  },1000)<br>  }<br>componentWillUnmount(){<br>  clearInterval(this.interval)<br>}</pre>\n<p>You can see that I ran a setInterval which increases the state â€œsecondâ€ by 1 in every second inside componentDidMount. And in componentWillUnmount, the interval isÂ cleared.</p>\n<h3>The useEffect hook</h3>\n<p>The useEffect hook takes two arguments. A callback function which is a must, and a dependency array which is optional. But the use of the dependency array will decide which lifecycle hook is actually running behind the scenes of useEffect.</p>\n<p>But first letâ€™s talk about the use of the dependency array.</p>\n<ul>\n<li>If you donâ€™t provide the dependency array in the useEffect, the hook runs on everyÂ render.</li>\n<li>If you provide an empty dependency array, the hook will run on initial render, because thereâ€™s nothing to be updated inside the component.</li>\n<li>If you provide a dependency array with one or more elements, the effect will run based on the change of at least one of the elements.</li>\n</ul>\n<h3>useEffect with componentDidMount</h3>\n<p>You can run useEffect only once when you mount the component, if you want the useEffect to function like componentDidMount. Here the effect will just run when the component mounts. To do this, just remove the dependency array.</p>\n<pre>useEffect(()=&gt;{<br>  setLoading(true)<br>})</pre>\n<p>If there is no dependency array, the effect will run whenever the component updates. It will still work as componentDidUupdate lifecycle. Because, every time a component updates it re-renders. And without a dependency array, useEffect will run on every mount andÂ render.</p>\n<h3>useEffect with componentDidUpdate</h3>\n<p>You can at least one element in a dependency array to run effect on every update on the dependency array elements. Which means if any of the elements of the dependency array updates then the effect willÂ run.</p>\n<pre>useEffect(()=&gt;{<br>  if(!loading){<br>    setRun(true)<br>  }<br>}, [loading])</pre>\n<p>Here, whenever the value of loading changes, the effectÂ runs.</p>\n<p>Whenever a component updates, the effect will look at the dependency array. And if there is any change in the elements, the effect willÂ run.</p>\n<h3>useEffect with componentWillUnmount</h3>\n<p>This time we will kill the component with useEffect. And we just need to return a function from the callback.</p>\n<pre>useEffect(()=&gt;{<br>    setRun(true)<br>    return ()=&gt;{<br>    console.log(\"component will unmount\")<br>  }<br>})</pre>\n<p>When you return a function from the callback of the effect, React will run it when it is time to unmount the component.</p>\n<h3>Conclusion</h3>\n<p>useEffect is one of the most confusing but essential topics in React. It runs three lifecycle methods under the hood. It is the substitute to lifecycle methods in functional components. React introduced this hook so that they can run effects based on fresh values. Also, reducing the complexity of the code by running three methods in only one hook function.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a9eaad2bc2d\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<p>If you ever check a react codebase with functional components, youâ€™ll notice two words used widely in the project. useState and useEffect. Of course if the components are functional. The work of useState is simple, creates a state and re-renders a component when it changes. But useEffect is something very strange behind the scenes. It is used for any operations while rendering a component. Such as, third party API calling, changing a state value while rendering a component etc.</p>\n<p>But useEffect does something more behind the scenes. For the functional components, it works as a substitute to the lifecycle methods, which are only available for class components. And thatâ€™s where the confusion occurs. A lot of developers use useEffect hook just to run an operation while rendering components. Here, I will describe how useEffect runs the lifecycle methods behind theÂ scenes.</p>\n<h3>The useEffect hook</h3>\n<p>The useEffect hook does the operation of three component lifecycle methods in a body. componentDidMount, componentDidUpdate and componentWillUnmount. But, we need to have ideas aboutÂ those.</p>\n<h3>componentDidMount</h3>\n<blockquote>A component <em>mounts</em> when itâ€™s added to theÂ screen.</blockquote>\n<p>componentDidMount is a lifecycle method where the component is created and inserted to the DOM. It runs when the component mounts. Here we can make API calls, changing stateÂ etc.</p>\n<pre>componentDidMount() {<br>  this.setState({<br>    loading: false<br>  })<br>}</pre>\n<h3>componentDidUpdate</h3>\n<blockquote>A component <em>updates</em> when it receives new props or state, usually in response to an interaction.</blockquote>\n<p>componentDidUpdate runs whenever a component updates. It takes the previous props and states as properties and runs if there is a mismatch between current and previous states andÂ props.</p>\n<pre>componentDidUpdate(prevProps, prevStates){<br>  if(this.props.loading !== prevProps.loading){<br>    return true<br>  }<br>}</pre>\n<p>You can decide whether you can update based on the change of props and/orÂ states.</p>\n<h3>componentWillUnmount</h3>\n<blockquote>A component <em>unmounts</em> when itâ€™s removed from theÂ screen.</blockquote>\n<p>This lifecycle runs right before the component is unmounted. Here all the subscriptions are cancelled, all the networks are disconnected and all the timers are cleared. In a nutshell, all the cleanup works are occurred in componentWillUnmount</p>\n<pre>componentDidMount(){<br>  this.interval = setInterval(()=&gt;{<br>    this.setState({<br>      seconds: seconds + 1<br>    })<br>  },1000)<br>  }<br>componentWillUnmount(){<br>  clearInterval(this.interval)<br>}</pre>\n<p>You can see that I ran a setInterval which increases the state â€œsecondâ€ by 1 in every second inside componentDidMount. And in componentWillUnmount, the interval isÂ cleared.</p>\n<h3>The useEffect hook</h3>\n<p>The useEffect hook takes two arguments. A callback function which is a must, and a dependency array which is optional. But the use of the dependency array will decide which lifecycle hook is actually running behind the scenes of useEffect.</p>\n<p>But first letâ€™s talk about the use of the dependency array.</p>\n<ul>\n<li>If you donâ€™t provide the dependency array in the useEffect, the hook runs on everyÂ render.</li>\n<li>If you provide an empty dependency array, the hook will run on initial render, because thereâ€™s nothing to be updated inside the component.</li>\n<li>If you provide a dependency array with one or more elements, the effect will run based on the change of at least one of the elements.</li>\n</ul>\n<h3>useEffect with componentDidMount</h3>\n<p>You can run useEffect only once when you mount the component, if you want the useEffect to function like componentDidMount. Here the effect will just run when the component mounts. To do this, just remove the dependency array.</p>\n<pre>useEffect(()=&gt;{<br>  setLoading(true)<br>})</pre>\n<p>If there is no dependency array, the effect will run whenever the component updates. It will still work as componentDidUupdate lifecycle. Because, every time a component updates it re-renders. And without a dependency array, useEffect will run on every mount andÂ render.</p>\n<h3>useEffect with componentDidUpdate</h3>\n<p>You can at least one element in a dependency array to run effect on every update on the dependency array elements. Which means if any of the elements of the dependency array updates then the effect willÂ run.</p>\n<pre>useEffect(()=&gt;{<br>  if(!loading){<br>    setRun(true)<br>  }<br>}, [loading])</pre>\n<p>Here, whenever the value of loading changes, the effectÂ runs.</p>\n<p>Whenever a component updates, the effect will look at the dependency array. And if there is any change in the elements, the effect willÂ run.</p>\n<h3>useEffect with componentWillUnmount</h3>\n<p>This time we will kill the component with useEffect. And we just need to return a function from the callback.</p>\n<pre>useEffect(()=&gt;{<br>    setRun(true)<br>    return ()=&gt;{<br>    console.log(\"component will unmount\")<br>  }<br>})</pre>\n<p>When you return a function from the callback of the effect, React will run it when it is time to unmount the component.</p>\n<h3>Conclusion</h3>\n<p>useEffect is one of the most confusing but essential topics in React. It runs three lifecycle methods under the hood. It is the substitute to lifecycle methods in functional components. React introduced this hook so that they can run effects based on fresh values. Also, reducing the complexity of the code by running three methods in only one hook function.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a9eaad2bc2d\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": ["reactjs", "useeffect"]
  },
  {
    "title": "Spread and Rest Operator in JavaScript",
    "pubDate": "2021-10-10 13:25:44",
    "link": "https://rezainfinity54.medium.com/spread-and-rest-operator-in-javascript-bed7060c3597?source=rss-eea2b02f8c4c------2",
    "guid": "https://medium.com/p/bed7060c3597",
    "author": "Serajur Reza Chowdhury",
    "thumbnail": "",
    "description": "\n<p>(â€¦) this operator is known as both spread and rest operator in JavaScript. Yes it is only one operator but it has two names. It depends on how you use these operators. And thatâ€™s the most confusing part. When you will call this spread and when you will call this rest. In this article, Iâ€™m going to briefly explain when the same operator is called spread and rest operator.</p>\n<h3>Rest Operator</h3>\n<p>(â€¦) we call this operator rest operator inside function parameters.</p>\n<p>A function can have any number of arguments.</p>\n<pre>function sum(a,b){</pre>\n<pre>return a+b;</pre>\n<pre>}</pre>\n<pre>console.log(sum(4,5))</pre>\n<p>We can have any number of parameters or arguments in while using functions,</p>\n<pre>// more parameters than arguments</pre>\n<pre>function sum(a,b){</pre>\n<pre>return a+b;</pre>\n<pre>}</pre>\n<pre>console.log(sum(4)) //output: NaN</pre>\n<p>In this example, we have more parameters than arguments. The parameters will be defined as undefined if it does not receive any value while calling the function. Because, no value is passed either from function call or a default value is not set to the parameters. So, in this example, the value of â€˜bâ€™ will be undefined.</p>\n<p>Or we can have any number of arguments or parameters in while using functions,</p>\n<pre>// more arguments than parameters</pre>\n<pre>function sum(a,b){</pre>\n<pre>return a+b;</pre>\n<pre>}</pre>\n<pre>console.log(sum(4,5,6,7)) // output: 9</pre>\n<p>Here, we have more arguments than parameters. So, the extra number of parameters will not be counted as the function receives two parameters. The remaining arguments will not have any effect on the function.</p>\n<p>You have seen in the second example that, while calling the function, we passed 4 arguments, but it receives 2 parameters. And in the first example, the function receives 2 parameters but only 1 argument isÂ passed.</p>\n<p>To solve this problem, the rest operator isÂ here.</p>\n<p>Just do apply the operator like theÂ example,</p>\n<pre>function sum(â€¦rest){</pre>\n<pre>let sum = 0;</pre>\n<pre>for(let i =0; i&lt;rest.length; i++){</pre>\n<pre>sum += rest[i]</pre>\n<pre>}</pre>\n<pre>return sum</pre>\n<pre>}</pre>\n<pre>console.log(sum(4,5,6,7)) // output: 22</pre>\n<p>In this example, you can pass any amount of arguments and use the rest operator like the example (â€¦rest). The value of the rest variable is an array containing all the arguments which is [4, 5, 6, 7]. Then you can add the values using a loop and return theÂ sum.</p>\n<p>Or, you can do something like thisÂ too,</p>\n<pre>function sum(a, â€¦rest){</pre>\n<pre>let sum = a;</pre>\n<pre>for(let i =0; i&lt;rest.length; i++){</pre>\n<pre>sum += rest[i]</pre>\n<pre>}</pre>\n<pre>return sum</pre>\n<pre>}</pre>\n<pre>console.log(sum(4,5,6,7)) // output: 22</pre>\n<p>Here, we have separated the first value of the arguments and used the others using the rest operator. Here, the value of rest is [5, 6,Â 7].</p>\n<p>But, use rest operator as the last parameter, otherwise it will throw an error. Because it takes all the arguments from any position till the last element of the arguments. As a result, any parameter after rest will not get any value from the argument.</p>\n<pre>function sum(a, â€¦rest, b){ // error : Rest parameter must be last formal parameter</pre>\n<pre>let sum = a;</pre>\n<pre>for(let i =0; i&lt;rest.length; i++){</pre>\n<pre>sum += rest[i]</pre>\n<pre>}</pre>\n<pre>return sum</pre>\n<pre>}</pre>\n<pre>console.log(sum(4,5,6,7))</pre>\n<h3>Spread Operator</h3>\n<p>(â€¦) we call this operator spread operator while working with arrays, objects, sets etc. It is used to â€˜spreadâ€™ the elements of the array one by one, which means you can work on the whole iterable in different scenario.</p>\n<p>It has a few useÂ cases,</p>\n<p>As function arguments,</p>\n<pre>function sum(a, â€¦rest){</pre>\n<pre>let sum = a;</pre>\n<pre>for(let i =0; i&lt;rest.length; i++){</pre>\n<pre>sum += rest[i]</pre>\n<pre>}</pre>\n<pre>return sum</pre>\n<pre>}</pre>\n<pre>const arr = [4,5,6,7]</pre>\n<pre>console.log(sum(â€¦arr)) // output: 22</pre>\n<p>Works same as the earlier example. In the last line, all the elements of the array is inserted to the function argument individually. Same as, sum(4,5,6,7)</p>\n<p>It works on built in functions too.</p>\n<pre>let arr = [1,2,3]</pre>\n<pre>console.log(Math.max(â€¦arr)) //output: 3</pre>\n<p>Combining multiple arrays inside a newÂ array,</p>\n<pre>let arr = [1,2,3]</pre>\n<pre>let arr1 = [4,5,6]</pre>\n<pre>let newArr = [ â€¦arr, â€¦arr1 , 7]</pre>\n<pre>console.log(newArr) //output: [ 1, 2, 3, 4, 5, 6, 7 ]</pre>\n<p>Here, we can also add extra individual element to anÂ array.</p>\n<p>We can copy an object to another objectÂ too.</p>\n<pre>let obj = {a:1, b:2, c:3}</pre>\n<pre>let objCopy = { â€¦obj }</pre>\n<pre>console.log(objCopy) // output: { a: 1, b: 2, c: 3 }</pre>\n<p>It can also be used sets. We can solve the problem of getting individual elements of an array only once using spread operator.</p>\n<pre>let arr = [1,2,1,4,3,3,1]</pre>\n<pre>let newArr = [â€¦new Set(arr)]</pre>\n<pre>console.log(newArr) // output: [ 1, 2, 4, 3 ]</pre>\n<pre>We can also use the in strings.</pre>\n<pre>let str= â€œHelloâ€</pre>\n<pre>console.log([â€¦str]) //output : [ â€˜Hâ€™, â€˜eâ€™, â€˜lâ€™, â€˜lâ€™, â€˜oâ€™ ]</pre>\n<pre>console.log([â€¦str]) //output : [ â€˜Hâ€™, â€˜eâ€™, â€˜lâ€™, â€˜lâ€™, â€˜oâ€™ ]</pre>\n<h3>Conclusion</h3>\n<p>It is really confusing when you would call an (â€¦) this as spread and rest. We call this rest when we call parameters of any number in a function. Other than that it is spread operator. Together they help to travel an iterable. And that is the similarity of theseÂ two.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bed7060c3597\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<p>(â€¦) this operator is known as both spread and rest operator in JavaScript. Yes it is only one operator but it has two names. It depends on how you use these operators. And thatâ€™s the most confusing part. When you will call this spread and when you will call this rest. In this article, Iâ€™m going to briefly explain when the same operator is called spread and rest operator.</p>\n<h3>Rest Operator</h3>\n<p>(â€¦) we call this operator rest operator inside function parameters.</p>\n<p>A function can have any number of arguments.</p>\n<pre>function sum(a,b){</pre>\n<pre>return a+b;</pre>\n<pre>}</pre>\n<pre>console.log(sum(4,5))</pre>\n<p>We can have any number of parameters or arguments in while using functions,</p>\n<pre>// more parameters than arguments</pre>\n<pre>function sum(a,b){</pre>\n<pre>return a+b;</pre>\n<pre>}</pre>\n<pre>console.log(sum(4)) //output: NaN</pre>\n<p>In this example, we have more parameters than arguments. The parameters will be defined as undefined if it does not receive any value while calling the function. Because, no value is passed either from function call or a default value is not set to the parameters. So, in this example, the value of â€˜bâ€™ will be undefined.</p>\n<p>Or we can have any number of arguments or parameters in while using functions,</p>\n<pre>// more arguments than parameters</pre>\n<pre>function sum(a,b){</pre>\n<pre>return a+b;</pre>\n<pre>}</pre>\n<pre>console.log(sum(4,5,6,7)) // output: 9</pre>\n<p>Here, we have more arguments than parameters. So, the extra number of parameters will not be counted as the function receives two parameters. The remaining arguments will not have any effect on the function.</p>\n<p>You have seen in the second example that, while calling the function, we passed 4 arguments, but it receives 2 parameters. And in the first example, the function receives 2 parameters but only 1 argument isÂ passed.</p>\n<p>To solve this problem, the rest operator isÂ here.</p>\n<p>Just do apply the operator like theÂ example,</p>\n<pre>function sum(â€¦rest){</pre>\n<pre>let sum = 0;</pre>\n<pre>for(let i =0; i&lt;rest.length; i++){</pre>\n<pre>sum += rest[i]</pre>\n<pre>}</pre>\n<pre>return sum</pre>\n<pre>}</pre>\n<pre>console.log(sum(4,5,6,7)) // output: 22</pre>\n<p>In this example, you can pass any amount of arguments and use the rest operator like the example (â€¦rest). The value of the rest variable is an array containing all the arguments which is [4, 5, 6, 7]. Then you can add the values using a loop and return theÂ sum.</p>\n<p>Or, you can do something like thisÂ too,</p>\n<pre>function sum(a, â€¦rest){</pre>\n<pre>let sum = a;</pre>\n<pre>for(let i =0; i&lt;rest.length; i++){</pre>\n<pre>sum += rest[i]</pre>\n<pre>}</pre>\n<pre>return sum</pre>\n<pre>}</pre>\n<pre>console.log(sum(4,5,6,7)) // output: 22</pre>\n<p>Here, we have separated the first value of the arguments and used the others using the rest operator. Here, the value of rest is [5, 6,Â 7].</p>\n<p>But, use rest operator as the last parameter, otherwise it will throw an error. Because it takes all the arguments from any position till the last element of the arguments. As a result, any parameter after rest will not get any value from the argument.</p>\n<pre>function sum(a, â€¦rest, b){ // error : Rest parameter must be last formal parameter</pre>\n<pre>let sum = a;</pre>\n<pre>for(let i =0; i&lt;rest.length; i++){</pre>\n<pre>sum += rest[i]</pre>\n<pre>}</pre>\n<pre>return sum</pre>\n<pre>}</pre>\n<pre>console.log(sum(4,5,6,7))</pre>\n<h3>Spread Operator</h3>\n<p>(â€¦) we call this operator spread operator while working with arrays, objects, sets etc. It is used to â€˜spreadâ€™ the elements of the array one by one, which means you can work on the whole iterable in different scenario.</p>\n<p>It has a few useÂ cases,</p>\n<p>As function arguments,</p>\n<pre>function sum(a, â€¦rest){</pre>\n<pre>let sum = a;</pre>\n<pre>for(let i =0; i&lt;rest.length; i++){</pre>\n<pre>sum += rest[i]</pre>\n<pre>}</pre>\n<pre>return sum</pre>\n<pre>}</pre>\n<pre>const arr = [4,5,6,7]</pre>\n<pre>console.log(sum(â€¦arr)) // output: 22</pre>\n<p>Works same as the earlier example. In the last line, all the elements of the array is inserted to the function argument individually. Same as, sum(4,5,6,7)</p>\n<p>It works on built in functions too.</p>\n<pre>let arr = [1,2,3]</pre>\n<pre>console.log(Math.max(â€¦arr)) //output: 3</pre>\n<p>Combining multiple arrays inside a newÂ array,</p>\n<pre>let arr = [1,2,3]</pre>\n<pre>let arr1 = [4,5,6]</pre>\n<pre>let newArr = [ â€¦arr, â€¦arr1 , 7]</pre>\n<pre>console.log(newArr) //output: [ 1, 2, 3, 4, 5, 6, 7 ]</pre>\n<p>Here, we can also add extra individual element to anÂ array.</p>\n<p>We can copy an object to another objectÂ too.</p>\n<pre>let obj = {a:1, b:2, c:3}</pre>\n<pre>let objCopy = { â€¦obj }</pre>\n<pre>console.log(objCopy) // output: { a: 1, b: 2, c: 3 }</pre>\n<p>It can also be used sets. We can solve the problem of getting individual elements of an array only once using spread operator.</p>\n<pre>let arr = [1,2,1,4,3,3,1]</pre>\n<pre>let newArr = [â€¦new Set(arr)]</pre>\n<pre>console.log(newArr) // output: [ 1, 2, 4, 3 ]</pre>\n<pre>We can also use the in strings.</pre>\n<pre>let str= â€œHelloâ€</pre>\n<pre>console.log([â€¦str]) //output : [ â€˜Hâ€™, â€˜eâ€™, â€˜lâ€™, â€˜lâ€™, â€˜oâ€™ ]</pre>\n<pre>console.log([â€¦str]) //output : [ â€˜Hâ€™, â€˜eâ€™, â€˜lâ€™, â€˜lâ€™, â€˜oâ€™ ]</pre>\n<h3>Conclusion</h3>\n<p>It is really confusing when you would call an (â€¦) this as spread and rest. We call this rest when we call parameters of any number in a function. Other than that it is spread operator. Together they help to travel an iterable. And that is the similarity of theseÂ two.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=bed7060c3597\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": ["javascript"]
  },
  {
    "title": "Map, Filter and Reduce In JavaScript",
    "pubDate": "2020-11-23 06:57:45",
    "link": "https://medium.com/swlh/map-filter-and-reduce-in-javascript-a0f9f50ed85b?source=rss-eea2b02f8c4c------2",
    "guid": "https://medium.com/p/a0f9f50ed85b",
    "author": "Serajur Reza Chowdhury",
    "thumbnail": "",
    "description": "\n<p>From ES6 version of JavaScript; map, filter and reduce function have been introduced in arrays. Which has become essential parts of life for JavaScript programmers. These methods use the functional programming concepts to the arrays. These methods automatically loop through the array so we donâ€™t need to write separate loop to traverse theÂ array.</p>\n<p>Now letâ€™s go through this method one byÂ one,</p>\n<h3>Map</h3>\n<p>Map function is used to loop through the array, runs operation on its elements and returns a new array. This is just itÂ does.</p>\n<pre>var arr= [1,2,3,4]</pre>\n<pre>var array=arr.map(elem=&gt; elem*2)</pre>\n<pre>console.log(array) // [ 2, 4, 6, 8 ]</pre>\n<p>Here, we have an array named â€œarrâ€ having 4 elements. We run the map function on each element of the array which is the â€œelemâ€ parameter. The function makes every element multiplied by 2 and inserts them in a new array. After traversal it returns the new array, where all the elements are multiplied byÂ 2.</p>\n<p>Returned outputâ€Šâ€”â€Š[2,4,6,8]</p>\n<p>Noteâ€Šâ€”â€ŠIt does not modify the original array. It traverses through the array and returns a newÂ array.</p>\n<h3>Filter</h3>\n<p>Like map, filter traverses through each element of an array and returns a new array. It does not modify the realÂ array.</p>\n<pre>var arr= [1,2,3,4]</pre>\n<pre>var array=arr.filter(elem=&gt; elem*2)</pre>\n<pre>console.log(array) // [ 2, 4, 6, 8 ]</pre>\n<p>But there is a difference.</p>\n<p>Letâ€™s look at the following 2 pieces ofÂ code,</p>\n<pre>var arr= [1,2,3,4]</pre>\n<pre>var array=arr.map(elem=&gt; elem&gt;2)</pre>\n<pre>console.log(array) // [ false, false, true, true ]</pre>\n<pre>var arr= [1,2,3,4]</pre>\n<pre>var array=arr.filter(elem=&gt; elem&gt;2)</pre>\n<pre>console.log(array) // [ 3,4 ]</pre>\n<p>In the map function, when we enter a condition it will return whether the condition is true for a specific element of an array. For example, for the first element of the array 1, the condition is false. So, it will return false. For 2 it is still false. For 3, it is true. For 4, it isÂ true.</p>\n<p>So, the final output isâ€Šâ€”â€Š[false, false, true,Â true]</p>\n<p>In the filter function, when we enter a condition it will return those elements for those the condition is true. For example, for the first element of the array 1, the condition is false. So, it will not return the element. For 2 it is still false. For 3, it is true so, it will return the element. For 4, it is the same asÂ 3.</p>\n<p>So, the final output isâ€Šâ€”â€Š[3,Â 4]</p>\n<h3>Reduce</h3>\n<p>Reduce is different from both map, filter. These two returns traverse through the array and returns a new array. But Reduce traverses through an array and reduces it to oneÂ element.</p>\n<p>Letâ€™s look at the following code,</p>\n<pre>var arr= [1,2,3,4]</pre>\n<pre>var value= arr.reduce(((acc, val)=&gt; acc+val),5)</pre>\n<pre>console.log(value) // 15</pre>\n<p>This reduce function takes a callback function and an initialValue, which is optional. The callback takes two parameters, the accumulator and the currentValue. Now if the initialValue is provided like the example, for the first iteration the accumulator is the initialValue and the currentValue is the first element of the array. Then it executes the code from the function, for this case adding the accumulator and currentValue and returnsÂ it.</p>\n<p>For the next iteration, the accumulator is the returned value which is 6 and currentValue is the next element of the array which is 2. These two gets added inside the callback and returned as accumulator which is 8. For the next iteration the accumulator is 8 and the currentValue is 3, the next element. And it continues like this until the array is fully traversed.</p>\n<p>The iteration of the array is givenÂ below,</p>\n<a href=\"https://medium.com/media/ca1148878b7c9144af94b2c95ee7d341/href\">https://medium.com/media/ca1148878b7c9144af94b2c95ee7d341/href</a><p>Letâ€™s look at anotherÂ code,</p>\n<pre>var arr= [1,2,3,4]</pre>\n<pre>var value= arr.reduce(((acc, val)=&gt; acc+val))</pre>\n<pre>console.log(value) // 10</pre>\n<p>Here the final output isâ€Šâ€”â€Š15</p>\n<p>There is another case where the initialValue is not set, the exception is the first iteration, where the accumulator will be the first element which is 1, and the currentValue will be the second element which is 2. These two gets added in the callback and returned, which is 3. In the next iteration, the accumulator is 3, the returned value and the currentValue is 3, the third element. These two gets added and returned. And it goes on until the whole array traversal finishes.</p>\n<p>The iteration of the array is givenÂ below,</p>\n<a href=\"https://medium.com/media/8a0257a181f70f22e7391b956e366fbf/href\">https://medium.com/media/8a0257a181f70f22e7391b956e366fbf/href</a><p>The final output isÂ 10</p>\n<p>The difference between having initialValue or not is the traversal number. The default accumulator value is the first element of the array so, the array traversal starts from the second element. If the initialValue is set then the traversal will start from the first element of theÂ array.</p>\n<h3>Conclusion</h3>\n<p>Map, Filter and Reduce are some widely used functions in JavaScript. These can be called the backbones of functional programming. For applying functional programming to array these 3 are theÂ basics.</p>\n<p>Happy JavaScripting.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a0f9f50ed85b\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://medium.com/swlh/map-filter-and-reduce-in-javascript-a0f9f50ed85b\">Map, Filter and Reduce In JavaScript</a> was originally published in <a href=\"https://medium.com/swlh\">The Startup</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "content": "\n<p>From ES6 version of JavaScript; map, filter and reduce function have been introduced in arrays. Which has become essential parts of life for JavaScript programmers. These methods use the functional programming concepts to the arrays. These methods automatically loop through the array so we donâ€™t need to write separate loop to traverse theÂ array.</p>\n<p>Now letâ€™s go through this method one byÂ one,</p>\n<h3>Map</h3>\n<p>Map function is used to loop through the array, runs operation on its elements and returns a new array. This is just itÂ does.</p>\n<pre>var arr= [1,2,3,4]</pre>\n<pre>var array=arr.map(elem=&gt; elem*2)</pre>\n<pre>console.log(array) // [ 2, 4, 6, 8 ]</pre>\n<p>Here, we have an array named â€œarrâ€ having 4 elements. We run the map function on each element of the array which is the â€œelemâ€ parameter. The function makes every element multiplied by 2 and inserts them in a new array. After traversal it returns the new array, where all the elements are multiplied byÂ 2.</p>\n<p>Returned outputâ€Šâ€”â€Š[2,4,6,8]</p>\n<p>Noteâ€Šâ€”â€ŠIt does not modify the original array. It traverses through the array and returns a newÂ array.</p>\n<h3>Filter</h3>\n<p>Like map, filter traverses through each element of an array and returns a new array. It does not modify the realÂ array.</p>\n<pre>var arr= [1,2,3,4]</pre>\n<pre>var array=arr.filter(elem=&gt; elem*2)</pre>\n<pre>console.log(array) // [ 2, 4, 6, 8 ]</pre>\n<p>But there is a difference.</p>\n<p>Letâ€™s look at the following 2 pieces ofÂ code,</p>\n<pre>var arr= [1,2,3,4]</pre>\n<pre>var array=arr.map(elem=&gt; elem&gt;2)</pre>\n<pre>console.log(array) // [ false, false, true, true ]</pre>\n<pre>var arr= [1,2,3,4]</pre>\n<pre>var array=arr.filter(elem=&gt; elem&gt;2)</pre>\n<pre>console.log(array) // [ 3,4 ]</pre>\n<p>In the map function, when we enter a condition it will return whether the condition is true for a specific element of an array. For example, for the first element of the array 1, the condition is false. So, it will return false. For 2 it is still false. For 3, it is true. For 4, it isÂ true.</p>\n<p>So, the final output isâ€Šâ€”â€Š[false, false, true,Â true]</p>\n<p>In the filter function, when we enter a condition it will return those elements for those the condition is true. For example, for the first element of the array 1, the condition is false. So, it will not return the element. For 2 it is still false. For 3, it is true so, it will return the element. For 4, it is the same asÂ 3.</p>\n<p>So, the final output isâ€Šâ€”â€Š[3,Â 4]</p>\n<h3>Reduce</h3>\n<p>Reduce is different from both map, filter. These two returns traverse through the array and returns a new array. But Reduce traverses through an array and reduces it to oneÂ element.</p>\n<p>Letâ€™s look at the following code,</p>\n<pre>var arr= [1,2,3,4]</pre>\n<pre>var value= arr.reduce(((acc, val)=&gt; acc+val),5)</pre>\n<pre>console.log(value) // 15</pre>\n<p>This reduce function takes a callback function and an initialValue, which is optional. The callback takes two parameters, the accumulator and the currentValue. Now if the initialValue is provided like the example, for the first iteration the accumulator is the initialValue and the currentValue is the first element of the array. Then it executes the code from the function, for this case adding the accumulator and currentValue and returnsÂ it.</p>\n<p>For the next iteration, the accumulator is the returned value which is 6 and currentValue is the next element of the array which is 2. These two gets added inside the callback and returned as accumulator which is 8. For the next iteration the accumulator is 8 and the currentValue is 3, the next element. And it continues like this until the array is fully traversed.</p>\n<p>The iteration of the array is givenÂ below,</p>\n<a href=\"https://medium.com/media/ca1148878b7c9144af94b2c95ee7d341/href\">https://medium.com/media/ca1148878b7c9144af94b2c95ee7d341/href</a><p>Letâ€™s look at anotherÂ code,</p>\n<pre>var arr= [1,2,3,4]</pre>\n<pre>var value= arr.reduce(((acc, val)=&gt; acc+val))</pre>\n<pre>console.log(value) // 10</pre>\n<p>Here the final output isâ€Šâ€”â€Š15</p>\n<p>There is another case where the initialValue is not set, the exception is the first iteration, where the accumulator will be the first element which is 1, and the currentValue will be the second element which is 2. These two gets added in the callback and returned, which is 3. In the next iteration, the accumulator is 3, the returned value and the currentValue is 3, the third element. These two gets added and returned. And it goes on until the whole array traversal finishes.</p>\n<p>The iteration of the array is givenÂ below,</p>\n<a href=\"https://medium.com/media/8a0257a181f70f22e7391b956e366fbf/href\">https://medium.com/media/8a0257a181f70f22e7391b956e366fbf/href</a><p>The final output isÂ 10</p>\n<p>The difference between having initialValue or not is the traversal number. The default accumulator value is the first element of the array so, the array traversal starts from the second element. If the initialValue is set then the traversal will start from the first element of theÂ array.</p>\n<h3>Conclusion</h3>\n<p>Map, Filter and Reduce are some widely used functions in JavaScript. These can be called the backbones of functional programming. For applying functional programming to array these 3 are theÂ basics.</p>\n<p>Happy JavaScripting.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a0f9f50ed85b\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://medium.com/swlh/map-filter-and-reduce-in-javascript-a0f9f50ed85b\">Map, Filter and Reduce In JavaScript</a> was originally published in <a href=\"https://medium.com/swlh\">The Startup</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "enclosure": {},
    "categories": ["reduce", "filters", "maps"]
  },
  {
    "title": "Prototype in JavaScript",
    "pubDate": "2020-10-27 12:52:15",
    "link": "https://rezainfinity54.medium.com/prototype-in-javascript-f446ed2bc29c?source=rss-eea2b02f8c4c------2",
    "guid": "https://medium.com/p/f446ed2bc29c",
    "author": "Serajur Reza Chowdhury",
    "thumbnail": "",
    "description": "\n<p>Prototype is an important concept of JavaScript. <strong>Prototype is a property that points the object.</strong> It is used for inheriting property from one object toÂ another.</p>\n<p>Before class-based structure, this prototype is used for assigning properties to a specific object and passing properties from parent to children object. Because prototype is based on functions.</p>\n<p>As I said earlier, <strong>prototype points the object</strong>. Every object has a constructor. When we declare an object, some built-in properties are inherited to the declared object from prototype, such as toString, valueOf, name, constructor etc. These built-in properties are inherited from <strong>Object.prototype</strong>.</p>\n<pre>function A(){</pre>\n<pre>}</pre>\n<pre>console.log(A.prototype)</pre>\n<p>In the example above, a function is declared. Now when I called the prototype property of the function, it returns an empty object. The function A has no custom property assigned to it. So, it returns an emptyÂ object.</p>\n<h3>Using Prototypes to Assign Properties</h3>\n<p>Normally, we can set properties likeÂ this,</p>\n<pre>function Person(name){</pre>\n<pre>this.name=name</pre>\n<pre>this.intro=function(){</pre>\n<pre>return `this is ${this.name}`</pre>\n<pre>}</pre>\n<pre>}</pre>\n<p>In this code, we created a function named Person, which takes an argument named name. Then we assigned two properties. One is name, a variable and a method namedÂ intro.</p>\n<p>We need to create object to use this function because it has properties. Thatâ€™s why we used this keyword before the properties. Because it makes the properties belong to the object. Also, a function of an object is aÂ method.</p>\n<p>We can use prototypes to define properties,</p>\n<pre>Person.prototype.sayName = function(){</pre>\n<pre>return `the name is ${this.name}`</pre>\n<pre>}</pre>\n<p>Here, we used the prototype property of Person to assign a method sayName().</p>\n<p>Now we can create instances of Person likeÂ this,</p>\n<pre>const p1= new Person(â€œRaphaelâ€)</pre>\n<p>And we can use the properties likeÂ this,</p>\n<pre>console.log(p1.intro()) // this is Raphael</pre>\n<pre>console.log(p1.sayName()) // the name is Raphael</pre>\n<h3>Prototypical Inheritance and Prototype Chain</h3>\n<p>Before class feature, this prototype property is used for inheritance. Using prototype we can create prototypical inheritance. And this happened in these two lines ofÂ code.</p>\n<pre>console.log(p1.hasOwnProperty(â€˜nameâ€™)) //true</pre>\n<pre>console.log(p1.hasOwnProperty(â€˜sayNameâ€™)) //false</pre>\n<p>When we assign properties inside Person property normally (without using prototype), every object of the Person will have those properties. In this case, the object p1 will have the properties name and intro. The hasOwnProperty() method checks whether a property is available in a specific object. In this case, it will look for the name property in p1 object. It is there, then it will returnÂ true.</p>\n<p>The sayName() property only belongs to the Person object. Every object refers to its constructor to define its properties. The prototype property assigns a property to an objectâ€™s constructor. Which means only that object will hold the property, not its instances.</p>\n<p>So, thatâ€™s why p1.hasOwnProperty(â€œsaynameâ€) returnsÂ false.</p>\n<p>But there is aÂ twist.</p>\n<p>When we write p1.sayName(), it returns anÂ output.</p>\n<p>Here, p1 uses the Personâ€™s very own sayName() property to show the output. Here p1 is considered as a child of Person, according to JavaScript as we created the instance p1 using Person object. Thus p1 inherits the property ofÂ Person.</p>\n<p>There is something called prototype chain. This is used for looking at properties to an object. If not found, it will look at the itsÂ parents.</p>\n<p>This is thing that has for p1. It did not any property of sayName() for p1. Then it looked its parent which is Person, and then executed the sayName() forÂ p1.</p>\n<p>This is how inheritance worked, before the arrival of classes in JavaScript.</p>\n<p>And it stillÂ works.</p>\n<h3>Conclusion</h3>\n<p>Prototype is used to assign properties to the object constructor. This constructor is used to create instances, which are basically children, based on JavaScript syntax. Prototype chain is used to assign properties from parent to child. And this is the main ideas of prototype.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f446ed2bc29c\" width=\"1\" height=\"1\" alt=\"\">\n",
    "content": "\n<p>Prototype is an important concept of JavaScript. <strong>Prototype is a property that points the object.</strong> It is used for inheriting property from one object toÂ another.</p>\n<p>Before class-based structure, this prototype is used for assigning properties to a specific object and passing properties from parent to children object. Because prototype is based on functions.</p>\n<p>As I said earlier, <strong>prototype points the object</strong>. Every object has a constructor. When we declare an object, some built-in properties are inherited to the declared object from prototype, such as toString, valueOf, name, constructor etc. These built-in properties are inherited from <strong>Object.prototype</strong>.</p>\n<pre>function A(){</pre>\n<pre>}</pre>\n<pre>console.log(A.prototype)</pre>\n<p>In the example above, a function is declared. Now when I called the prototype property of the function, it returns an empty object. The function A has no custom property assigned to it. So, it returns an emptyÂ object.</p>\n<h3>Using Prototypes to Assign Properties</h3>\n<p>Normally, we can set properties likeÂ this,</p>\n<pre>function Person(name){</pre>\n<pre>this.name=name</pre>\n<pre>this.intro=function(){</pre>\n<pre>return `this is ${this.name}`</pre>\n<pre>}</pre>\n<pre>}</pre>\n<p>In this code, we created a function named Person, which takes an argument named name. Then we assigned two properties. One is name, a variable and a method namedÂ intro.</p>\n<p>We need to create object to use this function because it has properties. Thatâ€™s why we used this keyword before the properties. Because it makes the properties belong to the object. Also, a function of an object is aÂ method.</p>\n<p>We can use prototypes to define properties,</p>\n<pre>Person.prototype.sayName = function(){</pre>\n<pre>return `the name is ${this.name}`</pre>\n<pre>}</pre>\n<p>Here, we used the prototype property of Person to assign a method sayName().</p>\n<p>Now we can create instances of Person likeÂ this,</p>\n<pre>const p1= new Person(â€œRaphaelâ€)</pre>\n<p>And we can use the properties likeÂ this,</p>\n<pre>console.log(p1.intro()) // this is Raphael</pre>\n<pre>console.log(p1.sayName()) // the name is Raphael</pre>\n<h3>Prototypical Inheritance and Prototype Chain</h3>\n<p>Before class feature, this prototype property is used for inheritance. Using prototype we can create prototypical inheritance. And this happened in these two lines ofÂ code.</p>\n<pre>console.log(p1.hasOwnProperty(â€˜nameâ€™)) //true</pre>\n<pre>console.log(p1.hasOwnProperty(â€˜sayNameâ€™)) //false</pre>\n<p>When we assign properties inside Person property normally (without using prototype), every object of the Person will have those properties. In this case, the object p1 will have the properties name and intro. The hasOwnProperty() method checks whether a property is available in a specific object. In this case, it will look for the name property in p1 object. It is there, then it will returnÂ true.</p>\n<p>The sayName() property only belongs to the Person object. Every object refers to its constructor to define its properties. The prototype property assigns a property to an objectâ€™s constructor. Which means only that object will hold the property, not its instances.</p>\n<p>So, thatâ€™s why p1.hasOwnProperty(â€œsaynameâ€) returnsÂ false.</p>\n<p>But there is aÂ twist.</p>\n<p>When we write p1.sayName(), it returns anÂ output.</p>\n<p>Here, p1 uses the Personâ€™s very own sayName() property to show the output. Here p1 is considered as a child of Person, according to JavaScript as we created the instance p1 using Person object. Thus p1 inherits the property ofÂ Person.</p>\n<p>There is something called prototype chain. This is used for looking at properties to an object. If not found, it will look at the itsÂ parents.</p>\n<p>This is thing that has for p1. It did not any property of sayName() for p1. Then it looked its parent which is Person, and then executed the sayName() forÂ p1.</p>\n<p>This is how inheritance worked, before the arrival of classes in JavaScript.</p>\n<p>And it stillÂ works.</p>\n<h3>Conclusion</h3>\n<p>Prototype is used to assign properties to the object constructor. This constructor is used to create instances, which are basically children, based on JavaScript syntax. Prototype chain is used to assign properties from parent to child. And this is the main ideas of prototype.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f446ed2bc29c\" width=\"1\" height=\"1\" alt=\"\">\n",
    "enclosure": {},
    "categories": ["javascript", "prototype"]
  },
  {
    "title": "Closures in JavaScript",
    "pubDate": "2020-10-14 12:48:57",
    "link": "https://medium.com/swlh/closures-in-javascript-92a2554b22f8?source=rss-eea2b02f8c4c------2",
    "guid": "https://medium.com/p/92a2554b22f8",
    "author": "Serajur Reza Chowdhury",
    "thumbnail": "",
    "description": "\n<p>JavaScript has some very features which sometimes makes the newbies scared. One of them is closures. It is one of the unique features of JavaScript.</p>\n<p>To define closure we can say that, it is a feature where the inner function has the access of the property/variable of the outer function. The important thing closure only works for a function nested inside another function, since we can write functions inside functions in JavaScript.</p>\n<p>But the thing is the inner function can access the property/variables of the outer function, not the parameters.</p>\n<p>So, closure has two prerequisites,</p>\n<p>Â· There will be nested functions</p>\n<p>Â· The inner function can access only the properties/variables of the outerÂ function</p>\n<p>Letâ€™s look at anÂ example,</p>\n<pre>function Hello(){</pre>\n<pre>var a=â€Helloâ€</pre>\n<pre>function Zero(){</pre>\n<pre>console.log(a)</pre>\n<pre>}</pre>\n<pre>Zero()</pre>\n<pre>}</pre>\n<pre>Hello()</pre>\n<pre>//output</pre>\n<pre>//Hello</pre>\n<p>Here, Hello() is a function which has returned another function named Zero(). Outside Zero() and inside Hello() there is variable named â€˜aâ€™ which holds a string. We called Zero() inside Hello() since Zero() is defined inside Hello(). So, when we call Hello() both Hello() and Zero() will execute. Inside Zero(), there is console.log(a) which print the value ofÂ â€˜aâ€™.</p>\n<p>Remember, â€˜aâ€™ was outside Zero() but it can access the variable because ofÂ closure.</p>\n<p>This is closure. EasyÂ right?</p>\n<p>Now letâ€™s dive deeper by looking at the following code,</p>\n<pre>function outer(){</pre>\n<pre>var b = 20</pre>\n<pre>return function inner(){</pre>\n<pre>var a = 10</pre>\n<pre>console.log(â€œa = â€œ+a)</pre>\n<pre>console.log(â€œb = â€œ+b)</pre>\n<pre>console.log(â€œâ€)</pre>\n<pre>a++</pre>\n<pre>b++</pre>\n<pre>}</pre>\n<pre>}</pre>\n<pre>var in1= outer()</pre>\n<pre>var in2= outer()</pre>\n<pre>in1()</pre>\n<pre>in1()</pre>\n<pre>in1()</pre>\n<pre>in2()</pre>\n<pre>The output,</pre>\n<pre>a = 10</pre>\n<pre>b = 20</pre>\n<pre>a = 10</pre>\n<pre>b = 21</pre>\n<pre>a = 10</pre>\n<pre>b = 22</pre>\n<pre>a = 10</pre>\n<pre>b = 20</pre>\n<p>Here, we stored the returned function. This outer() function has a variable â€˜bâ€™ and a function inner() that is returned. When we call the function outer() to a variable, it returns and store the inner() function to the variable.</p>\n<p>Now, thatâ€™s the tricky part. After storing the inner function inside in1, we called it three times. The function inner() prints the value of â€˜aâ€™ and â€˜bâ€™ and increments those. In the first call, the output was 10 andÂ 20.</p>\n<p>In the second time, the output was 10 and 21. Because, â€˜aâ€™ was inside inner() but b was outside inner() but inside outer(). In each call of a specific variable, like in1, â€˜bâ€™ remains because the outer function existed but the inner function gets destroyed after execution. Because of closure â€˜bâ€™ gets incremented by the inner function. So, after each call â€˜aâ€™ is newly created but â€˜bâ€™Â stays.</p>\n<p>So, every time you call in1 here, the value of â€˜aâ€™ always remains constant but, â€˜bâ€™ always gets increased by 1. No matter how many times we call in1, the inner() function gets executed.</p>\n<p>In the third time the output will be 10 andÂ 22.</p>\n<p>We called outer() to another variable in2. Just like earlier, after calling in2 for the first time, the output will be 10 andÂ 20.</p>\n<p>So, the summeryÂ is,</p>\n<p>1. When in1 is invoked for the first time, the a is created and set to 10 and b shows 20 and gets incremented.</p>\n<p>2. When in1 is invoked for the second time, a is created and set to 10 and b shows 21(from the previous increment) and gets incremented.</p>\n<p>3. When in1 is invoked for the second time, a is created and set to 10 and b shows 22(from the previous increment) and gets incremented.</p>\n<p>4. When in1 is invoked for the first time, the a is created and set to 10 and b shows 20 and gets incremented.</p>\n<h3>Conclusion</h3>\n<p>Closures are one of the confusing features of JavaScript. But it is very essential. Once understood, it will look like a piece ofÂ cake.</p>\n<p>Hopefully this helps you understand the concepts ofÂ closure.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=92a2554b22f8\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://medium.com/swlh/closures-in-javascript-92a2554b22f8\">Closures in JavaScript</a> was originally published in <a href=\"https://medium.com/swlh\">The Startup</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "content": "\n<p>JavaScript has some very features which sometimes makes the newbies scared. One of them is closures. It is one of the unique features of JavaScript.</p>\n<p>To define closure we can say that, it is a feature where the inner function has the access of the property/variable of the outer function. The important thing closure only works for a function nested inside another function, since we can write functions inside functions in JavaScript.</p>\n<p>But the thing is the inner function can access the property/variables of the outer function, not the parameters.</p>\n<p>So, closure has two prerequisites,</p>\n<p>Â· There will be nested functions</p>\n<p>Â· The inner function can access only the properties/variables of the outerÂ function</p>\n<p>Letâ€™s look at anÂ example,</p>\n<pre>function Hello(){</pre>\n<pre>var a=â€Helloâ€</pre>\n<pre>function Zero(){</pre>\n<pre>console.log(a)</pre>\n<pre>}</pre>\n<pre>Zero()</pre>\n<pre>}</pre>\n<pre>Hello()</pre>\n<pre>//output</pre>\n<pre>//Hello</pre>\n<p>Here, Hello() is a function which has returned another function named Zero(). Outside Zero() and inside Hello() there is variable named â€˜aâ€™ which holds a string. We called Zero() inside Hello() since Zero() is defined inside Hello(). So, when we call Hello() both Hello() and Zero() will execute. Inside Zero(), there is console.log(a) which print the value ofÂ â€˜aâ€™.</p>\n<p>Remember, â€˜aâ€™ was outside Zero() but it can access the variable because ofÂ closure.</p>\n<p>This is closure. EasyÂ right?</p>\n<p>Now letâ€™s dive deeper by looking at the following code,</p>\n<pre>function outer(){</pre>\n<pre>var b = 20</pre>\n<pre>return function inner(){</pre>\n<pre>var a = 10</pre>\n<pre>console.log(â€œa = â€œ+a)</pre>\n<pre>console.log(â€œb = â€œ+b)</pre>\n<pre>console.log(â€œâ€)</pre>\n<pre>a++</pre>\n<pre>b++</pre>\n<pre>}</pre>\n<pre>}</pre>\n<pre>var in1= outer()</pre>\n<pre>var in2= outer()</pre>\n<pre>in1()</pre>\n<pre>in1()</pre>\n<pre>in1()</pre>\n<pre>in2()</pre>\n<pre>The output,</pre>\n<pre>a = 10</pre>\n<pre>b = 20</pre>\n<pre>a = 10</pre>\n<pre>b = 21</pre>\n<pre>a = 10</pre>\n<pre>b = 22</pre>\n<pre>a = 10</pre>\n<pre>b = 20</pre>\n<p>Here, we stored the returned function. This outer() function has a variable â€˜bâ€™ and a function inner() that is returned. When we call the function outer() to a variable, it returns and store the inner() function to the variable.</p>\n<p>Now, thatâ€™s the tricky part. After storing the inner function inside in1, we called it three times. The function inner() prints the value of â€˜aâ€™ and â€˜bâ€™ and increments those. In the first call, the output was 10 andÂ 20.</p>\n<p>In the second time, the output was 10 and 21. Because, â€˜aâ€™ was inside inner() but b was outside inner() but inside outer(). In each call of a specific variable, like in1, â€˜bâ€™ remains because the outer function existed but the inner function gets destroyed after execution. Because of closure â€˜bâ€™ gets incremented by the inner function. So, after each call â€˜aâ€™ is newly created but â€˜bâ€™Â stays.</p>\n<p>So, every time you call in1 here, the value of â€˜aâ€™ always remains constant but, â€˜bâ€™ always gets increased by 1. No matter how many times we call in1, the inner() function gets executed.</p>\n<p>In the third time the output will be 10 andÂ 22.</p>\n<p>We called outer() to another variable in2. Just like earlier, after calling in2 for the first time, the output will be 10 andÂ 20.</p>\n<p>So, the summeryÂ is,</p>\n<p>1. When in1 is invoked for the first time, the a is created and set to 10 and b shows 20 and gets incremented.</p>\n<p>2. When in1 is invoked for the second time, a is created and set to 10 and b shows 21(from the previous increment) and gets incremented.</p>\n<p>3. When in1 is invoked for the second time, a is created and set to 10 and b shows 22(from the previous increment) and gets incremented.</p>\n<p>4. When in1 is invoked for the first time, the a is created and set to 10 and b shows 20 and gets incremented.</p>\n<h3>Conclusion</h3>\n<p>Closures are one of the confusing features of JavaScript. But it is very essential. Once understood, it will look like a piece ofÂ cake.</p>\n<p>Hopefully this helps you understand the concepts ofÂ closure.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=92a2554b22f8\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://medium.com/swlh/closures-in-javascript-92a2554b22f8\">Closures in JavaScript</a> was originally published in <a href=\"https://medium.com/swlh\">The Startup</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "enclosure": {},
    "categories": ["javascript", "closure"]
  }
]
